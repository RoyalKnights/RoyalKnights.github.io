{"meta":{"title":"RoyalKnights","subtitle":null,"description":"皇家小骑士的小博客","author":"皇家小骑士","url":""},"pages":[{"title":"comment","date":"2020-06-11T02:57:18.397Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"","keywords":"留言板"},{"title":"donate","date":"2020-06-11T02:57:18.397Z","updated":"2020-06-11T02:57:18.397Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"Royal Knights"}],"posts":[{"title":"ubuntu安装mysql8.0","slug":"fwd/1577939110","date":"2020-01-02T04:25:10.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2020/01/02/fwd/1577939110/","link":"","permalink":"/2020/01/02/fwd/1577939110/","excerpt":"","text":"下载deb进入mysql官方下载地址下载deb文件，上传到ubuntu服务器 安装执行(-i后面为包名) dpkg -i mysql-apt-config_0.8.14-1_all.deb 选择ok执行更新命令 apt update 执行安装命令 apt install mysql-server -y 设置root账户密码再次确认 选择传统加密选择包升级自动重启 设置远程连接以root账户登录mysql mysql -u root -p 输入密码修改mysql权限表 use mysql; update user set host = &#39;%&#39; where user = &#39;root&#39;; flush privileges; 重启数据库 service mysql restart","categories":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}],"tags":[],"keywords":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}]},{"title":"jsdelivr+github使用","slug":"fwd/1576134854","date":"2019-12-12T07:14:14.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/12/12/fwd/1576134854/","link":"","permalink":"/2019/12/12/fwd/1576134854/","excerpt":"","text":"前提1.有github账号2.安装git工具 创建github仓库进入github首页-Repository-new输入对应的仓库信息-点击创建复制仓库地址 克隆仓库到本地在本地右键打开Git Bash Here-执行克隆命令 git clone https://github.com/RoyalKnights/cdn.git 此时将本地仓库克隆到了本地将想要jsdelivr访问的文件放入仓库(我这里建立一个img文件放入一张图片)进入仓库文件夹,把文件添加并提交到仓库更多教程 cd cdn git add --all git commit - m &quot;描述信息“ 上传githubgit push -u origin master 此时会让你输入github账号和密码 配置版本号进入仓库点击releases创建一个版本号 通过jsdelivr访问https://cdn.jsdelivr.net/gh/&lt;github账号&gt;/&lt;仓库名称&gt;@&lt;版本号&gt;/&lt;文件路径&gt;/&lt;文件名&gt; 不输入版本号默认访问最新版本 例如浏览器输入https://cdn.jsdelivr.net/gh/RoyalKnights/cdn/cdn@v1.0/img/test.jpg","categories":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}],"tags":[],"keywords":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}]},{"title":"Ubuntu下Docker快速部署Nextcloud","slug":"fwd/1575538139","date":"2019-12-05T09:28:59.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/12/05/fwd/1575538139/","link":"","permalink":"/2019/12/05/fwd/1575538139/","excerpt":"","text":"安装Dockerapt install docker.io Docker拉取Nextcloud镜像docker pull nextcloud Docker启动Nextcloud容器docker run --name nextcloud -p 9533:80 -v /root/nextcloud:/var/www/html/data -d nextcloud -name: 为容器指定一个名称-d:后台启动-p: 指定端口映射，格式为：主机(宿主)端口:容器端口-v: 绑定一个输入ip地址以及对应的端口号即可进入nextcloud，若选择默认的数据库。输入管理员账号密码即可若需要连接mysql，输入对应的mysql信息即可，若需要连接宿主机的mysql请往下看 其他命令删除容器或者镜像 命令 说明 docker ps -a 查看所有容器 docker stop &lt;CONTAINER ID&gt; 停止指定容器 docker rm &lt;CONTAINER ID&gt; 删除指定容器 docker images 查看所有镜像 docker rmi &lt;IMAGE ID&gt; 删除镜像 删除步骤：查看容器(获取容器id)-停止容器(删除前需停止)-删除容器(此时镜像还在，可以重启启用)-查看镜像(获取镜像id)-删除镜像 连接宿主机的mysql***mysql需要开启远程连接权限，若不清楚怎么开启，可查看这篇文章查看docker0所对应的ip即可与主机的端口进行通信 ifconfig 在数据库的配置中选择mysql，输入账号密码数据库名以及连接宿主机的ip和端口号即可。","categories":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}],"tags":[],"keywords":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}]},{"title":"ubuntu部署node环境以及mysql","slug":"fwd/1575437991","date":"2019-12-04T05:39:51.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/12/04/fwd/1575437991/","link":"","permalink":"/2019/12/04/fwd/1575437991/","excerpt":"","text":"工具 腾讯云服务器一台(安装Ubuntu Servers 18.04.1 LTS 64位) xshell(终端模拟)和xftp(远程文件上传) 点击这里家庭学校免费版 navicat for mysql (mysql可视化管理工具) 连接服务器打开xshell新建会话输入主机号点击连接输入用户名输入密码连接成功 变更root用户*** 阿里云或者不想用root登陆的跳过这一步 用当前账户修改root密码sudo passwd root 修改ssh配置文件执行 sudo vim /etc/ssh/sshd_config 点击i进入插入模式找到PermitRootLogin prohibit-password改为PermitRootLogin yes并且去掉#号依次按下esc(退出插入模式) :(输入指令) wq(w保存q退出) 回车(确认更改) 重启ssh服务sudo service ssh restart 重新连接在xsell中按照先前的步骤重新建立一个连接，用户名为root，密码为设置的密码@前面为root则连接成功 删除旧用户*** 不想删除则忽略这一步 userdel -r username node环境部署安装node执行 apt-get install nodejs -y *** -y代表yes，若没有输入，则在安装过程中根据提示输入yes即可 若没有root权限则执行 sudo apt-get install nodejs -y *** 没有root权限则加sudo执行，后续不做说明 安装完成后执行node -v查看是否成功 安装npm执行 apt-get install npm -y 安装完成后执行npm -v查看是否成功 安装pm2pm2是node的一个进程管理工具安装命令 npm install -g pm2 pm2常用命令 命令 说明 pm2 start app.js pm2启动 pm2 start app.js –name=”newname” 以newname这个名字进行启动 pm2 start app.js –watch 当文件有变化时自动重启 pm2 list 查看pm2所有的应用程序 pm2 stop 停止命令，可接all，停止所有的命令，Id号，停止指定id的命令，进程名，停止指定名字的命令 pm2 restart 重启命令，参数同stop pm2 delete 删除命令，参数同stop pm2 save 保存服务 pm2 startup 把已启动服务加到systemd中 ***后两条命令为开机自启 部署mysql环境安装指令apt-get install mysql-server -y apt-get install mysql-client -y apt-get install libmysqlclient-dev -y 变更密码查看默认账号和密码 cat /etc/mysql/debian.cnf 用默认账户登陆mysql，输入默认密码 mysql -u debian-sys-maint -p 更改密码 use mysql; update mysql.user set authentication_string=password(&#39;password&#39;) where user=&#39;root&#39; and Host =&#39;localhost&#39;; update user set plugin=&quot;mysql_native_password&quot;; flush privileges; quit; 重启mysql service mysql restart 以root账户登陆 mysql -u root -p 修改远程连接打开修改musql配置文件 vim /etc/mysql/mysql.conf.d/mysqld.cnf 将#bind-address = 127.0.0.1注释 修改mysql权限表以root账户登陆 use mysql; update user set host = &#39;%&#39; where user = &#39;root&#39;; flush privileges; 重启mysql service mysql restart 打开navicat-新建mysql连接点击测试连接-成功后确认 上传文件可直接在xshell中打开xftp 左边窗口选择文件右键传输即可上传 搭建ftp服务器安装 apt-get install vsftpd 修改sftpd.conf文件,将#write_enable=YES前的#去掉，表示允许上传。其他配置请自行百度 vim /etc/vsftpd.conf 更改/etc/ftpusers，注释掉root用户，表示可以通过root用户登陆 vim /etc/ftpusers 重启服务 /etc/init.d/vsftpd restart 彻底删除 apt-get remove --purge vsftpd","categories":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}],"tags":[],"keywords":[{"name":"fwd","slug":"fwd","permalink":"/categories/fwd/"}]},{"title":"promise对象使用","slug":"qd/1572353580","date":"2019-10-29T12:53:00.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/10/29/qd/1572353580/","link":"","permalink":"/2019/10/29/qd/1572353580/","excerpt":"","text":"大量的异步操作，如果要顺序执行的话，则会形成回调地狱，通过promise对象，即可解决回调地狱。以node为例，假设我们有一个需求1.判断test.txt是否存在，不存在则输出错误2.若存在则删除这个文件3.写入一个新的文件假如不用promise对象，代码如下 const fs=require(&#39;fs&#39;) fs.stat(&#39;./test.txt&#39;,(err,states)=&gt;{ if(err){ console.log(err) }else{ console.log(&quot;文件存在&quot;) fs.unlink(&#39;./test.txt&#39;,(err)=&gt;{ if(err){ console.log(err) }else{ console.log(&quot;文件删除成功&quot;) fs.writeFile(&#39;./test1.txt&#39;,&#39;HelloWorld&#39;,(err)=&gt;{ if(err){ console.log(err) }else{ console.log(&quot;新文件写入成功&quot;) //若有更多的操作则继续在这写，形成回调地狱 } }) } }) } }) 当操作顺序执行的操作越多的时候，便会一直写回调，形成回调地狱。此时引入promise对象即可解决这个问题。promise的构造函数中包含两个参数，resolve-成功之后的回调函数，reject-失败之后的回调函数。 const promise=new promise((resolve,reject)=&gt;{ if(/*异步操作成功*/){ resolve()//可以传参,传入.then(msg) }else{ reject()//可以传参,传入.then(err) } }) 当实例生成后，.then()指定resolve的回调函数，.catch指定reject的回调函数。用promise对象重写上述例子 const fs = require(&#39;fs&#39;) //将每个Promise对象封装成函数，返回Promise对象 //判断文件是否存在 function isExit() { return new Promise((resolve, reject) =&gt; { fs.stat(&#39;./test.txt&#39;, (err) =&gt; { if (err) { reject(&#39;err1&#39;) } else { resolve(&#39;文件存在&#39;) } }) }) } function deleteF() { return new Promise((resolve, reject) =&gt; { fs.unlink(&#39;./test.txt&#39;, (err) =&gt; { if (err) { reject(&#39;err2&#39;) } else { resolve(&#39;文件删除成功&#39;) } }) }) } function writeF() { return new Promise((resolve, reject) =&gt; { fs.writeFile(&#39;./test1.txt&#39;, &#39;HelloWorld&#39;, (err) =&gt; { if (err) { reject(&#39;err3&#39;) } else { resolve(&#39;新文件写入成功&#39;) } }) }) } //链式操作,所有错误共用一个catch isExit() .then((msg) =&gt; { console.log(msg) return deleteF() }) .then((msg) =&gt; { console.log(msg) return writeF() }) .then((msg) =&gt; { console.log(msg) }) .catch((err) =&gt; { console.log(err) }) 若要中断链式操作，则抛出一个错误信息即可 isExit() .then((msg) =&gt; { console.log(msg) return deleteF() }) .then((msg) =&gt; { console.log(msg) return writeF() }) .then((msg) =&gt; { console.log(msg) }) .then(()=&gt;{ console.log(&#39;这是多余的操作，但是要存在，下一个then不执行&#39;) //抛出错误信息中断下一个操作 throw new Error(&#39;停止输出&#39;) }) .then(()=&gt;{ console.log(&#39;看看我输出来了吗&#39;) }) .catch((err) =&gt; { console.log(err) }) 输出结果 文件存在 文件删除成功 新文件写入成功 这是多余的操作，但是要存在，下一个then不执行 Error: 停止输出 at isExit.then.then.then.then","categories":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}],"tags":[],"keywords":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}]},{"title":"NVM安装使用教程","slug":"qt/1571642507","date":"2019-10-21T07:21:47.000Z","updated":"2020-06-11T02:57:18.398Z","comments":true,"path":"2019/10/21/qt/1571642507/","link":"","permalink":"/2019/10/21/qt/1571642507/","excerpt":"","text":"nvm主要用于切换node版本 卸载node安装nvm前最好对以前安装的node进行卸载在控制面版或者应用列表中卸载nodejs删除npm的相关文件例如C:\\Users\\\\AppData\\Roaming\\npm 下载nvm进入GitHub下载安装版打开 安装node输入nvm list available可以查看可以安装的版本输入nvm install vXX.XX.XXv后面接版本号，即可安装对应版本 安装node需要科学上网，若不能科学上网，打开nvm的安装根路径里的settings.txt加入下列两行一行为node的下载镜像，一行为npm的下载镜像node_mirror:https://npm.taobao.org/mirrors/node/ npm_mirror:https://npm.taobao.org/mirrors/npm/ 执行nvm use XX.XX.XX即可执行和切换相应的版本 输入nvm list可查看使用版本","categories":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}],"tags":[],"keywords":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}]},{"title":"node.js教程--持续更新中","slug":"ht/1573006884","date":"2019-09-24T12:09:14.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/09/24/ht/1573006884/","link":"","permalink":"/2019/09/24/ht/1573006884/","excerpt":"","text":"node安装进入node官网第一个为长期支持的版本，可以理解成稳定版，第二个为发布版本，含有最新的功能。可根据需求下载安装。下载完成后，打开文件选择路径即可安装。***若需要切换不同的版本，则需要使用nvm NVM安装使用教程 REPLNode.js中REPL(交互式解释器) 表示一个电脑的环境，可以在终端输入命令，并接受响应 读取(read) - 读取用户输入的js代码 执行(exec)- 执行用户输入的js代码 打印(print)- 打印用户输入的js代码 循环(loop)- 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出 类似于浏览器的调试窗口，可执行简单的表达式运算，这里不多做解释。附上一些常用的命令 ctrl + c 按下两次 - 退出 Node REPL ctrl + d - 退出 Node REPL 向上/向下 键 - 查看输入的历史命令 .help - 列出使用命令 在E盘放入一个hello.js，内容为console.log(&quot;hello&quot;),执行终端 自定义模块1.创建一个模块(一个js就是一个模块)2.导出一个模块(module.exports=name)3.引入一个模块并且调用(require) 这里用个例子来解释模块的导出以及导入dog.js功能模块 let dog={ dogname:&#39;wangcai&#39;, say(){ console.log(&#39;wangwang&#39;) } } module.exports=dog main.js引用模块 //引入模块，赋值给cal const Module=require(&#39;./dog&#39;) console.log(Module.dogname); Module.say() 终端执行 内置模块文件操作fs 模块提供了一个 API，用于以模仿标准 POSIX 函数的方式与文件系统进行交互。 这里全部操作只讲解异步操作，同步操作请参照官方文档，同步操作中，可以用try catch语句捕获异常。 异步读取文件目录 fs.readdir(path[, options], callback) 参数 解释 path 路径 options 可选参数,encoding(可选编码默认UTF-8),withFileTypes(默认false)) callback 回调函数,err(为null则成功,否则返回错误信息),files(目录中的文件名的数组) 文件目录 代码 const fs=require(&#39;fs&#39;) fs.readdir(&#39;./&#39;,(err,file)=&gt;{ //读取正确err为null，否则为错误信息 if (err) throw err console.log(file) }) fs.readdir(&#39;./dir&#39;,(err,file)=&gt;{ if (err) throw err console.log(file) }) 输出结果 创建目录 fs.mkdir(path[, options], callback) 参数 解释 path 路径 options 可选参数,recursive(recursive 属性默认值: false),mode( Windows 上不支持默认值: 0o777) callback 回调函数,err(为null则成功,否则返回错误信息) 代码 const fs=require(&#39;fs&#39;) fs.mkdir(&#39;./test&#39;,(err)=&gt;{ if (err) throw err console.log(&#39;创建目录成功&#39;) }) 重命名 fs.rename(oldPath, newPath, callback 参数 解释 oldPath 原文件名字 newPath 重命名后的文件名字 callback 回调函数,err(为null则成功,否则返回错误信息) 代码 const fs=require(&#39;fs&#39;) fs.rename(&#39;./test&#39;,&#39;./test1&#39;,(err)=&gt;{ if(err) throw err console.log(&quot;重命名成功&quot;) }) 写文件 fs.writeFile(file, data[, options], callback) 参数 解释 file 文件名或文件描述符 data 写入的数据 options 可选参数,encoding(可选编码默认UTF-8),mode(模式),flag(文件系统标志默认w) callback 回调函数,err为null则成功,否则返回错误信息 const fs=require(&#39;fs&#39;) fs.writeFile(&#39;./test.txt&#39;,&#39;HelloWorld&#39;,[&#39;utf-8&#39;,&#39;w&#39;],(err)=&gt;{ if (err) throw err console.log(&#39;文件写入成功&#39;) }) 读文件 fs.readFile(path[, options], callback) 参数 解释 path 文件路径 options 可选参数encoding(可选编码默认null),flag(文件系统标志默认r) callback 回调参数,err(错误信息),data(返回的数据,如果没指定编码,返回原始的 buffer) const fs=require(&#39;fs&#39;) fs.readFile(&#39;./test.txt&#39;,&#39;utf-8&#39;,(err,data)=&gt;{ if(err) throw err console.log(data) }) 删除文件 fs.unlink(path, callback) 代码 const fs=require(&#39;fs&#39;) fs.unlink(&#39;./test.txt&#39;,(err)=&gt;{ if(err) throw err console.log(&#39;文件删除成功&#39;) }) 更多请点击fs官方文档 url处理url 模块用于处理与解析 URL url.parse在最新node中为遗留属性，这里不做讲解，采用URL类进行讲解 URL 类 new URL(input[, base]) 参数 解释 input 要解析的绝对或相对的 URL。如果 input 是相对路径，则需要 base。 如果 input 是绝对路径，则忽略 base base 如果 input 不是绝对路径，则为要解析的基本 URL 代码 const myURL = new URL(&#39;https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&#39;) console.log(myURL.href)//整个连接 console.log(myURL.protocol)//协议 console.log(myURL.username)//用户名 console.log(myURL.password)//密码 console.log(myURL.host)//主机 console.log(myURL.hostname)//主机名 console.log(myURL.port)//端口号 console.log(myURL.pathname)//路径名 console.log(myURL.search)//请求参数 console.log(myURL.hash)//哈希值 console.log(myURL.searchParams)//URL查询参数的URLSearchParams对象 结果URLSearchParams 类URLSearchParams API 提供对 URL 查询部分的读写权限 方法/属性 含义 .append(name, value) 在查询字符串中附加一个新的键值对 .delete(name) 删除所有键为name的键值对 .get(name) 返回键是name的第一个键值对的值。如果没有对应的键值对，则返回null .getAll(name) 返回键是name的所有键值对的值，如果没有满足条件的键值对，则返回一个空的数组 .has(name) 如果存在至少一对键是 name 的键值对则返回 true .set(name, value) 将 URLSearchParams 对象中与 name 相对应的值设置为 value。 如果已经存在键为 name 的键值对，则将第一对的值设为 value 并且删除其他对。 如果不存在，则将此键值对附加在查询字符串后 .toString() 返回查询参数序列化后的字符串，必要时存在百分号编码字符 .entries() 在查询中的每个键值对上返回一个 ES6 Iterator。 迭代器的每一项都是一个 JavaScript Array。 Array 的第一个项是键 name， Array 的第二个项是值 value .keys() 在每一个键值对上返回一个键的 ES6 Iterator .values() 在每一个键值对上返回一个值的 ES6 Iterator 代码 const myURL = new URL(&#39;https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&#39;) //.searchParams方法返回的已经是个URLSearchParams类 console.log(myURL.searchParams.get(&#39;query&#39;)) //构建一个URLSearchParams类 let params = new URLSearchParams(&#39;a=1&amp;a=2&amp;b=3&#39;); params.append(&#39;c&#39;, &#39;3&#39;) console.log(params.toString()) params.delete(&#39;b&#39;) console.log(params.toString()) console.log(params.getAll(&#39;a&#39;)) console.log(params.has(&#39;a&#39;)) params.set(&#39;a&#39;, &#39;4&#39;) console.log(params.toString()) for(let arr of params.entries()){ console.log(arr[0]+&#39;-&#39;+arr[1]) } for (let name of params.keys()) { console.log(name); } for (let value of params.values()) { console.log(value); } 结果更多请点击url官方文档 第三方模块使用实例在npm的官网上，有许多第三方模块，这里以发送邮件的模块–nodemailer为例，讲述如何使用第三方模块0.初始化npm项目进入终端，执行npm init输入命令后，分别填写项目信息，也可以不填，填写完成后输入yes。1.首页搜索nodemailer2.找到帮助文档或者官网3.安装模块 npm install nodemailer 4.查看示例使用并且修改 &#39;use strict&#39;; //引入node模块 const nodemailer = require(&#39;nodemailer&#39;); //创建发送邮件的对象 let transporter = nodemailer.createTransport({ host: &#39;smtp.qq.com&#39;, //发送方邮箱类型主机号，通过node包里的well-known里services.json查询 port: 465, //端口号 secure: true, // 465端口为true, 其他端口为false /*通过well-known查询的qq邮箱信息 &quot;QQ&quot;: { &quot;domains&quot;: [&quot;qq.com&quot;], &quot;host&quot;: &quot;smtp.qq.com&quot;, &quot;port&quot;: 465, &quot;secure&quot;: true }, */ auth: { user: &#39;xxxxxxxxx@qq.com&#39;, //发送方邮箱地址 pass: &#39;xxxxxxxxx&#39; //mtp验证码 } /* qq邮箱mtp开启方法 设置-账户-POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 开通POP3/SMTP服务，其他自行查找或百度 */ }); transporter.sendMail({ from: &#39;&quot;HelleWorld有限公司&quot; &lt;xxxxxx@qq.com&gt;&#39;, // 发件方地址 to: &#39;xxxxxxxx@qq.com,xxxxxxxx@qq.com&#39;, // 多个邮箱用逗号隔开 subject: &#39;验证码&#39;, // 主题 text: &#39;您的验证码信息是123456&#39;, // 文本信息 html: &#39;&lt;b&gt;您的验证码信息是123456&lt;/b&gt;&#39; // html信息,若使用text则html无效 }); 简易爬虫通过get方法获取目标网站，通过cheerio分析网站内容1.数据处理部分 /*基本构架*/ //根据协议引入http或者https模块 const http=require(&#39;http&#39;) let url=&#39;https://movie.douban.com/&#39; http.get(url,(res)=&gt;{ //数据分段，只有接受数据会触发data 事件chunk每次接受新的数据片段 res.on(&#39;data&#39;,chunk=&gt;{ console.log(&#39;数据传输&#39;) }) //数据传输完成 res.on(&#39;end&#39;,()=&gt;{ console.log(&#39;数据传输完毕&#39;) }) }).on(&#39;error&#39;,(err)=&gt;{ console.log(&#39;请求错误&#39;) }) 案例:将豆瓣电影的网页爬取下来存在一个html页面下 const http = require(&#39;https&#39;) const fs = require(&#39;fs&#39;) let url = &#39;https://movie.douban.com/&#39; http.get(url, (res) =&gt; { //数据分段，只有接受数据会触发data 事件chunk每次接受新的数据片段 let rawData = &#39;&#39; res.on(&#39;data&#39;, chunk =&gt; { rawData += chunk }) //数据传输完成 res.on(&#39;end&#39;, () =&gt; { fs.writeFile(&#39;./douban.html&#39;, rawData, (err) =&gt; { if (err) throw err console.log(&#39;文件写入成功&#39;) }) }) }).on(&#39;error&#39;, (err) =&gt; { console.log(err) }) 2.安全判断 const http = require(&#39;https&#39;) const fs = require(&#39;fs&#39;) let url = &#39;https://movie.douban.com/&#39; http.get(url, (res) =&gt; { //状态码 const { statusCode } = res //const statusCode=res.statusCode //请求头 const contentType = res.headers[&#39;content-type&#39;] let error if (statusCode !== 200) { error = new Error(&#39;请求状态错误&#39;); } else if (!/^ text\\/html/.test(contentType)) { //正则验证 error = new Error(&#39;请求类型错误&#39;); } if (error) { console.log(error); res.resume();//清除缓存 return false; } }).on(&#39;error&#39;, (err) =&gt; { console.log(err) }) 3.分析网站内容通过npm命令安装cheerio模块 npm install cheerio 类似于jq选择器选择元素 const cheerio = require(&#39;cheerio&#39;) const $ = cheerio.load(&#39;&lt;div class=&quot;box&quot;&gt;&lt;img src=&quot;pictruelink1&quot;&gt;&lt;img src=&quot;pictruelink2&quot;&gt;&lt;/div&gt;&#39;) // 类似于jq选择器的各种用法 //$(&#39;.box&#39;).text(&#39;title&#39;) //$(&#39;.box&#39;).addClass(&#39;welcome&#39;) //console.log($.html()) $(&#39;img&#39;).each((index,el)=&gt;{ console.log(index) console.log($(el).attr(&#39;src&#39;)) }) 案例:将豆瓣电影所有图片地址爬取下来打印 const http = require(&#39;https&#39;) const cheerio = require(&#39;cheerio&#39;) let url = &#39;https://movie.douban.com/&#39; http.get(url, (res) =&gt; { //安全判断 //状态码 const { statusCode } = res //const statusCode=res.statusCode //请求头 const contentType = res.headers[&#39;content-type&#39;] let error if (statusCode !== 200) { error = new Error(&#39;请求状态错误&#39;); } else if (!/^text\\/html/.test(contentType)) { //正则验证 error = new Error(&#39;请求类型错误&#39;); } if (error) { console.log(error); res.resume();//清除缓存 return false; } //数据分段，只有接受数据会触发data 事件chunk每次接受新的数据片段 let rawData = &#39;&#39; res.on(&#39;data&#39;, chunk =&gt; { rawData += chunk }) //数据传输完成 res.on(&#39;end&#39;, () =&gt; { const $ = cheerio.load(rawData) $(&#39;img&#39;).each((index,el)=&gt;{ console.log($(el).attr(&#39;src&#39;)) }) }) }).on(&#39;error&#39;, (err) =&gt; { console.log(err) }) express框架安装方式 npm install express HelloWorld const express=require(&#39;express&#39;) //express实例化 const app=express() //get方法，接受前端的get请求 app.get(&#39;/&#39;,(req,res)=&gt;{ res.send(&#39;Hello World&#39;) }) //监听9501端口，运行服务器 app.listen(9501,()=&gt;{ console.log(&#39;Server Start&#39;) }) 在浏览器运行http://localhost:9501/开始服务器 get接收参数.query属性接收get方法传过来的数据 const express=require(&#39;express&#39;) //express实例化 const app=express() app.get(&#39;/login&#39;,(req,res)=&gt;{ //console.log(req.query) //打印结果 //{ username: &#39;bob&#39;, password: &#39;123456&#39; } let { username,password}=req.query if(username===&#39;bob&#39;&amp;&amp;password===&#39;123456&#39;){ res.send({code:0,msg:&#39;login success&#39;}) }else{ res.send({code:-1,msg:&#39;login fail&#39;}) } }) app.listen(9501,()=&gt;{ console.log(&#39;Server Start&#39;) }) 在浏览器输入http://localhost:9501/login?username=bob&amp;password=123456开启服务器查看运行结果post接收参数post解析参数需要用到body-parser插件安装方法 npm install body-parser body属性接受post方法传递过来的参数 const express=require(&#39;express&#39;) const bodypaser=require(&#39;body-parser&#39;) //express实例化 const app=express() //app.use为中间件的使用方法，见下文 //解析表单数据 application/x-www-form-urlencoded app.use(bodypaser.urlencoded({ extended: false })) //解析json格式数据 application/json app.use(bodypaser.json()) app.post(&#39;/login&#39;,(req,res)=&gt;{ //console.log(req.body) // { username: &#39;bob&#39;, password: &#39;123456&#39; } let { username,password}=req.body if(username===&#39;bob&#39;&amp;&amp;password===&#39;123456&#39;){ res.send({code:0,msg:&#39;login success&#39;}) }else{ res.send({code:-1,msg:&#39;login fail&#39;}) } }) app.listen(9501,()=&gt;{ console.log(&#39;Server Start&#39;) }) 中间件中间件就是在收到请求之后以及发出响应之前执行的一些函数，也可将其理解成一个拦截器。原型为: app.use([path,] function [, function…]) path如果为空，则默认为’/‘中间件分以下三种1.内置中间件express.static用来处理静态资源，是express的内置中间件，具体用如下 //在node里建立一个img文件夹放入pic.jpg const express=require(&#39;express&#39;) //引入path路径处理模块 const path=require(&#39;path&#39;) const app=express() //使用内置中间件 //__dirname为当前文件所在的目录，path中的join方法用于拼接路径 //app.use(express.static(path.join(__dirname,&#39;./img&#39;))) //访问http://localhost:9595/pic.jpg即可查看图片 app.use(&#39;/tupian&#39;,express.static(path.join(__dirname,&#39;./img&#39;))) //访问http://localhost:9595/tupian/pic.jpg即可查看图片 app.listen(9595,()=&gt;{ console.log(&#39;Server Start&#39;) }) 2.自定义中间件自定义中间件的函数为function(req,res,next)，可以为全局的，可以为局部的。next表示是否继续往下执行例:多端口验证token(这里token先用一个随机的字符串表示) const express=require(&#39;express&#39;) const app=express() //先进入中间件，判断传入的是否有一个参数为token有则往下执行，没有则返回结果，不往下执行 app.use(&#39;/&#39;,(req,res,next)=&gt;{ let {token}=req.query if(token){ next() }else{ res.send(&#39;缺少token&#39;) } }) app.get(&#39;/test1&#39;,(req,res)=&gt;{ res.send(&#39;test1&#39;) }) app.get(&#39;/test2&#39;,(req,res)=&gt;{ res.send(&#39;test2&#39;) }) app.listen(9595,()=&gt;{ console.log(&#39;Server Start&#39;) }) //访问http://localhost:9595/test1，显示缺少token //http://localhost:9595/test2?token=fsdklv，显示test2 例:路由的封装express.Router()方法封装路由，封装路由可以让工程模块化。建立一个router.js const express=require(&#39;express&#39;) //express.Router()方法封装路由 const router=express.Router() router.get(&#39;/login&#39;,(req,res)=&gt;{ res.send(&quot;this is login&quot;) }) router.get(&#39;/register&#39;,(req,res)=&gt;{ res.send(&quot;this is register&quot;) }) //导出router module.exports=router main.js const express=require(&#39;express&#39;) //引入路由 const userRouter=require(&#39;./router&#39;) const app=express() //中间件，路径为/user进入封装好的路由 app.use(&#39;/user&#39;,userRouter) app.listen(9595,()=&gt;{ console.log(&#39;Server Start&#39;) }) //访问http://localhost:9595/user/login 显示this is login //访问http://localhost:9595/user/register,显示this is register 3.第三方中间件上文中使用body-parser插件就是第三方中间件的用法 mysql安装mysql依赖 npm install mysql 数据库连接 var mysql = require(&#39;mysql&#39;); var connection = mysql.createConnection({ host: &#39;localhost&#39;,//主机地址 （默认：localhost） user: &#39;root&#39;,//用户名 password: &#39;logan123&#39;,//密码 database: &#39;testDB&#39;//数据库名 }); //连接数据库 connection.connect((err) =&gt; { if (err) throw err console.log(&#39;数据库连接成功&#39;) }); //断开数据库 connection.end(); 更多配置 sql语句操作。具体的sql语句的用法这边不做讲解，以查询数据和插入数据为例。user数据表 var mysql = require(&#39;mysql&#39;); var connection = mysql.createConnection({ host: &#39;localhost&#39;,//主机地址 （默认：localhost） user: &#39;root&#39;,//用户名 password: &#39;******&#39;,//密码 database: &#39;testDB&#39;//数据库名 }); //连接数据库 connection.connect((err) =&gt; { if (err) throw err console.log(&#39;数据库连接成功&#39;) }); connection.query(&quot;select * from user&quot;,(err, result)=&gt;{ if(err) throw err console.log(result) }) connection.query(&quot;insert into user values(4,&#39;rose&#39;,&#39;789654&#39;)&quot;,(err, result)=&gt;{ if(err) throw err console.log(result) }) //断开数据库 connection.end(); 执行结果user表防sql注入 var mysql = require(&#39;mysql&#39;); var connection = mysql.createConnection({ host: &#39;localhost&#39;,//主机地址 （默认：localhost） user: &#39;root&#39;,//用户名 password: &#39;******&#39;,//密码 database: &#39;testDB&#39;//数据库名 }); //连接数据库 connection.connect((err) =&gt; { if (err) throw err console.log(&#39;数据库连接成功&#39;) }); let addsql=&quot;insert into user values(?,?,?)&quot; let addSqlParams = [4, &#39;rose&#39;,&#39;789654&#39;]; connection.query(addsql,addSqlParams,(err, result)=&gt;{ if(err) throw err console.log(result) }) //断开数据库 connection.end(); 解决跨域 cors模块 express中可用cors来解决跨域问题安装方法 npm install cors 使用 const cors=require(&#39;cors&#39;) const app=express() app.use(cors()) 文件上传安装multer模块 npm install multer 配置storage(磁盘存储引擎) const storage = multer.diskStorage({ destination: (req, file, cb) =&gt; { //cb第二个参数为存储的路径 cb(null, &#39;./upload&#39;) }, filename: (req, file, cb) =&gt; { //cb第二个参数为文件的名字 cb(null, file.originalname) } }) 实例化multer const upload = multer({ storage: storage }); post方法使用 //.single为单个文件上传。键名为&#39;key&#39; app.post(&#39;/upload&#39;, upload.single(&#39;key&#39;), (req, res) =&gt; { res.send(&#39;ok&#39;); }) 优化代码1.设置上传文件大小数量限制 const uploadConfig = multer({ limits:{ fileSize: 50*1024, //上传文件数 files: 5, } } //若文件大小不正确，则会抛出一个错误 2.设置文件上传类型 const uploadConfig = multer({ limits:{ fileSize: 50*1024, files: 5 }, fileFilter:(req,file,cb)=&gt;{ if(file.mimetype == &#39;image/jpeg&#39;||file.mimetype == &#39;image/jpg&#39;){ cb(null, true) } else { cb(null, false) //抛出一个错误 cb(new Error()) } } }) //这里若文件类型不正确，则不会接收，但是不会抛出错误,所以需要手动抛出一个错误 完整代码 const uploadConfig = multer({ limits: { fileSize: 100*1024, files: 5 }, storage: multer.diskStorage({ destination: (req, file, cb) =&gt; { //cb第二个参数为存储的路径 cb(null, &#39;./upload&#39;) }, filename: (req, file, cb) =&gt; { //截取文件的后缀名 let exts = file.originalname.split(&#39;.&#39;) //取最后一个元素 let ext = exts[exts.length - 1] //文件名为时间戳加上4个随机数字 let filename = (new Date()).getTime() let randnum = parseInt(1000 + Math.random() * 8999) cb(null, `${filename}${randnum}.${ext}`) } }), fileFilter: (req, file, cb) =&gt; { if (file.mimetype == &#39;image/jpg&#39; || file.mimetype == &#39;image/jpeg&#39;) { cb(null, true) } else { cb(null, false) //抛出一个错误 cb(new Error()) } } }) let upload = uploadConfig.single(&#39;key&#39;) app.post(&#39;/upload&#39;, (req, res) =&gt; { upload(req, res, (err) =&gt; { if (err instanceof multer.MulterError) { return res.send(err.message) } else if (err) { //此处接收文件类型限制抛出的错误 return res.send(&quot;type error&quot;) } res.send(&quot;sucess&quot;) }) }) JWTJSON Web Token基于Token的身份验证安装 npm install jsonwebtoken 生成token jwt.sign(payload, secretOrPrivateKey, [options, callback]) payload-存储加密信息secretOrPrivateKey-key,加密的钥匙expiresIn-设置有效期，不带单位默认为秒。也可以是时间跨度字符串 let payload={ us:&#39;test&#39;, ps:&#39;123456&#39; } let secretOrPrivateKey=&quot;dsadas&quot; jwt.sign(payload,secretOrPrivateKey, {expiresIn:60*60},(err,token)=&gt;{ if(err) throw err console.log(token) }) 解密token jwt.verify(token, secretOrPublicKey, [options, callback]) token-由jwt.sign生成的tokensecretOrPrivateKey-加密的key，用于解析token的payload里的信息 let token=&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cyI6IjEyMyIsInBzIjoiMTIzIiwiaWF0IjoxNTc1MzQyNjI4LCJleHAiOjE1NzU0MjkwMjh9.Fk7w2zeve5NNLYRJpt3ErIR0INvpFgpdi_4oNr9xju0&quot; let secretOrPrivateKey=&quot;dsadas&quot; jwt.verify(token, secretOrPrivateKey, (err, data) =&gt;{ if(err.name===&quot;TokenExpiredError&quot;){ console.log(&quot;token过期&quot;) }else if(err.name===&quot;TokenExpiredError&quot;){ console.log(&quot;无效的token&quot;) } else{ console.log(data) } })","categories":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}],"tags":[],"keywords":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}]},{"title":"谷歌浏览器安装vue-devtools","slug":"qt/1567991928","date":"2019-09-09T01:18:48.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/09/09/qt/1567991928/","link":"","permalink":"/2019/09/09/qt/1567991928/","excerpt":"","text":"安装之前，确保有node环境 下载github下载地址下载的方法有很多，这里就不一一叙述。如果不会git语法，最直接的方式就是点击clone or download下载zip到桌面解压。 安装cd命令进入到vue-devtools-dev目录运行npm install(也可使用淘宝镜像cnpm install)打开vue-devtools-dev\\shells\\chrome这个目录下的manifest.json文件，将persistent中的false改为true运行npm run build(也可使用淘宝镜像cnpm run build)打开谷歌浏览器扩展程序菜单-&gt;更多工具-&gt;扩展程序-&gt;加载已解压扩展程序未打开开发者模式的要在这个界面打开开发者模式选择vue-devtools -&gt; shells -&gt; chrome文件夹此时安装完成 当然，如果你能够科学上网，在谷歌浏览器的插件市场直接搜索安装vue-devtools是最方便的。","categories":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}],"tags":[],"keywords":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}]},{"title":"git基础教程(更新中)","slug":"qt/1567158704","date":"2019-08-30T09:51:44.000Z","updated":"2020-06-11T02:57:18.398Z","comments":true,"path":"2019/08/30/qt/1567158704/","link":"","permalink":"/2019/08/30/qt/1567158704/","excerpt":"","text":"window下载和安装点击进入官网下载下载完成后打开 安装完成后使用命令行或者GitBash输入用户名和邮箱git config –list可查看所有配置信息 git基础使用初始化git仓库1.创建仓库在要创建的目录右键Git Bash Here,打开命令窗口。输入$ mkdir &lt;filename&gt;2.初始化git用cd 命名进入文件夹或者直接进入文件夹右键Git Bash Here输入$ git int，此时在文件夹内创建了一个.git的文件夹3.克隆仓库$ git clone [url] 把文件添加到版本库1.把文件添加到仓库$ git add &lt;filename&gt;此时文件还未保存在仓库，需要提交后才能保存，这样可以保证能上传很多文件后在提交* $ git add –all提交所有文件包括删除没有的2.把文件提交到仓库$ git commit -m “”m后面输入此次提交的描述信息，这样方面后续从历史记录里查找 这里我新建了一个txt文件放在test目录下 查看工作区状态此时我们输入$ git status查看工作区状态这里显示没有需要提交的修改，工作的目录是干净的然后我们修改txt的内容，再次查看提示文件被修改但是还没有准备提交输入$ git diff查看修改的内容（全部，后面可接文件名）再次提交重复提交的两部 版本回退1.查看历史记录输入$ git log查看历史(第一项为版本号)2.版本回退$ git reset –hard HEAD^当前版本表示HEAD，上一个版本加上^，依次加或者~加回退的版本数量，例如HEAD~100 回退到100版本前。若想回到未来的版本，则在hard后添加部分版本号，系统会自动查找。3.回退后查找新版本的版本号输入git reflog记录内一次命令 4.放弃工作区的状态当不想要新添加的内容又添加提交到仓库的内容时，可以通过$ git checkout – &lt;filename&gt;放弃工作区的修改在txt中随意添加一行此时还未使用添加命令，输入$ git checkout – test.txt 如果使用添加命令添加到暂存区，则使用git reset HEAD ，再使用$ git checkout恢复 4.删除命令$ rm &lt;filename&gt;删除文件$ rm -rf &lt;directory name&gt;删除文件夹 git标签$ git tag v1.0 给最新一次提交打上（HEAD）”v1.0”的标签若要添加描述信息，则$git tag -a tagName -m “”给以前的版本打标签，则在后面添加部分版本号","categories":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}],"tags":[],"keywords":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}]},{"title":"ES6快速入门","slug":"qd/1567146678","date":"2019-08-30T06:31:18.000Z","updated":"2020-06-11T02:57:11.481Z","comments":true,"path":"2019/08/30/qd/1567146678/","link":"","permalink":"/2019/08/30/qd/1567146678/","excerpt":"","text":"常量const:声明的常量不可改变，声明时必须初始化 const pi =3.1415926; console.log(pi); 使用const定义的数组和对象，其值是可变的，但是不能对其进行重新赋值 const a=[]; a[0]=1; console.log(a[0]);//输出1 const a=[1];//报错 作用域let:let所声明的变量，只在let命令所在的代码块({}包裹的地方)内有效，let不能在相同的作用域重复申明代码 for(var i=0;i&lt;5;i++){} console.log(i); for(let j=0;j&lt;5;j++){} console.log(j); 输出5Uncaught ReferenceError: j is not defined 箭头函数箭头函数相当于一个匿名函数，基本构造为 ()=&gt;{} ()相当于function(),如果传入的参数为1个，则可以省略()，但是没有括号的时候不能省略。{}为函数体，若只含又一个表达式，则可以省略return和{}，若含有多条语句则都不能省略。 const a=x=&gt;x+1; console.log(a(1)) const b=(a,b)=&gt;{ a=a+1; b=b+2; return a+b; } console.log(b(1,2)) 输出26注意:若但表达式返回的是一个对象，则要添加()，否则和函数体语法冲突 v =&gt; {k: v} // 错误 v =&gt; ({k: v}) // 正确 箭头函数中的this和普通函数this的区别普通函数中的this谁调用他，谁就是this箭头函数本身没有this，只能沿着作用域链往上找，直到找到一个确定的this，如果找不到，那就是Windows或undefined var a=2; var obj1={ a:1, show:function() { console.log(this.a); } } obj1.show(); //obj1条用的show,所以this指向obj1 var obj2={ a:1, show:()=&gt;console.log(this.a) } obj2.show(); //箭头函数本身没有this，就沿着作用域往上找，找到最外层的作用域，window 参数配置默认参数在参数后面直接加=设置默认参数 const cul=(x=1,y=1,z=1)=&gt;x+y+z; console.log(cul(2,2,2));//输出6 console.log(cul());//输出3 可变参数…加变量名可作为一个可变化长度的参数数组传入函数中 const cul=(...n)=&gt;{ let sum=0; n.forEach(item=&gt;{ sum=sum+item; }) return sum; }; console.log(cul(2,2,2));//输出6 可用…加变量名合并数组 const b=[4,5] const a=[1,2,3,...b] console.log(a) promise对象promise对象","categories":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}],"tags":[],"keywords":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}]},{"title":"less基本语法","slug":"qd/1566232486","date":"2019-08-19T16:34:46.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/08/20/qd/1566232486/","link":"","permalink":"/2019/08/20/qd/1566232486/","excerpt":"","text":"注释less的注释有两种方式，一种为css用的/**/,这种注释的方法会被less所编译成css。另一种为//，这种不会被less所编译less代码 /*会被编译*/ //不会被编译 css输出代码 /*会被编译*/ 变量less中用@变量名:值的方法来生命变量less代码 @test_width:100px; @test_color:red; .box{ width:@test_width ; height:@test_width ; background:@test_color ; } css输出代码 .box { width: 100px; height: 100px; background: red; } 混入可以将定义好的样式引入到另一个样式中，类似于函数的调用less代码 //这里是没带参数的嵌套 .addradius(){ border-radius: 10px; } //这里是带参数的嵌套 .addboder(@test_color){ border: 1px solid @test_color; } //这里是带默认值的参数嵌套,keyi1 .addmargin(@v:10px){ margin: @v; } .box{ width:100px; height:100px ; background:red; .addradius; .addboder(red); .addmargin; } css输出代码 .box { width: 100px; height: 100px ; background: red; border-radius: 10px; border: 1px solid red; margin: 10px; } 匹配模式相当于条件判断，只有满足条件才匹配less代码 //括号内的不带符号的参数代表条件 .pos(r){ position: relative; } .pos(a){ position: absolute; } .pos(f){ position: fixed; } .box{ .pos(a); } css输出代码 .box { position: absolute; } 运算less里的变量可以直接进行运算less代码 @lenght:100px; //减法的变量之间一定要有空格 .box{ width: (@lenght + 20)/4; height: @lenght - 20*3; } css输出代码 .box { width: 30px; height: 40px; } 嵌套可以实现多层嵌套以及多个关系嵌套less代码 ul{ list-style: none; width: 100px; li{ height: 20px; a{ background: red; //&amp;相当于上一个选择器 &amp;:hover{ background: blue; } } } &gt;.left{ float: left; width: 10px; height: 10px; background-color: red; } .right{ float: right; width: 10px; height: 10px; background-color: red; } } css输出代码 ul { list-style: none; width: 100px; } ul li { height: 20px; } ul li a { background: red; } ul li a:hover { background: blue; } ul &gt; .left { float: left; width: 10px; height: 10px; background-color: red; } ul .right { float: right; width: 10px; height: 10px; background-color: red; } @arguments@arguments包含所有变量less代码 .addborder(@l:1px,@s:solid,@c:red){ border: @arguments; } .box{ .addborder(); } css输出代码 .box { border: yellow solid red; }","categories":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}],"tags":[],"keywords":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}]},{"title":"Vue教程","slug":"qd/1564969377","date":"2019-08-05T01:42:57.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/08/05/qd/1564969377/","link":"","permalink":"/2019/08/05/qd/1564969377/","excerpt":"","text":"Vue安装与使用1.使用cdn &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; or &lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt; 2.官网下载进入英文官网 第一个为开发版本，包含完整的警告和调试模式 第二个为生产版本，压缩了代码，删除了警告 根据自己的需求下载合适的版本，需要注意的是中文的官网点击下载出现的是源码在html文件中用script标签直接引入Vue就可使用 Vue起步Vue基本结构每个 Vue 应用都需要通过实例化 Vue 来实现 var vm = new Vue() Vue构造器基本的参数 参数 含义 el 表示当前new的这个vue的实例，即要控制哪个区域 data 用于定义属性，当属性改变时，html的内容也发生改变，不需要手动操作DOM元素 methods 用于定义函数 html代码 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{msg}}&lt;/p&gt; &lt;p&gt;{{show()}}&lt;/p&gt; &lt;/div&gt; js代码 var vm=new Vue({ el:&quot;#app&quot;, data:{ msg:&#39;Hello&#39; }, methods:{ show:function(){ return &#39;World&#39; } } }) 输出结果： Vue基本指令&#123;&#123;&nbsp;&#125;&#125;和v-cloak&#123;&#123;&nbsp;&#125;&#125;插值表达式的作用：用于输出对象属性和函数返回值v-cloak作用：解决插值表达式闪烁的问题，即在为了防止出现Vue的变量名，在DOM染完成后才显示用法：html: &lt;p v-cloak&gt;{{msg}}&lt;/p&gt; css [v-cloak]{ display: none; } v-text 和 v-html默认的v-text是没有闪烁的，和插值表达式的不同是v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的占位符，而不会把整个元素的内容清空 &lt;p v-text=&quot;msg&quot;&gt;haha&lt;/p&gt; 输出结果：Hello 使用 v-html 指令用于输出 html 代码 v-bind 和 v-onv-bind用于绑定属性，简写 :v-on用于绑定方法，简写 @代码示例 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;val&quot;/&gt; &lt;br/&gt; &lt;span v-on:mouseover=&quot;show()&quot;&gt;鼠标移到这&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { val:&quot;这里绑定了输入框的值&quot; }, methods: { show: function() { alert(&quot;移到这了！&quot;) } } }) &lt;/script&gt; 输出结果： v-modelv-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{msg}}&lt;/p&gt; &lt;input v-model=&quot;msg&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { msg: &quot;绑定&quot; } }) &lt;/script&gt; 查看更多示例 Vue绑定样式例: .color{ color: #ffffff; } .bkcolor{ background-color: #ff0000; .size{ font-size: 20px; } :class为v-bind:class的简写1.使用数组绑定 &lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;[&#39;color&#39;,&#39;bkcolor&#39;,&#39;size&#39;]&quot;&gt;这是一个用Vue绑定样式的标题&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, //也可将数组的内容写在data域里 }) &lt;/script&gt; 结果：2.数组中使用三元表达式或者镶嵌对象 &lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;[flag?&#39;color&#39;:&#39;&#39;,&#39;bkcolor&#39;,&#39;size&#39;]&quot;&gt;这是一个用Vue绑定样式的标题1&lt;/h1&gt; &lt;h1 :class=&quot;[&#39;color&#39;,&#39;bkcolor&#39;,{&#39;size&#39;:flag}]&quot;&gt;这是一个用Vue绑定样式的标题2&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ flag:false //也可将数组内容写在data区域 } }) &lt;/script&gt; 3.使用对象 &lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;h_class&quot;&gt;这是一个用Vue绑定样式的标题&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ h_class:{ color:true, bkcolor:true, size:false } } }) &lt;/script&gt; 4.使用:style(v-bind:style)内联样式 Vue循环指令循环使用 v-for 指令1.迭代数组 &lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;item in arr&quot;&gt;{{item}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ arr:[1,2,3,4,5] } }) &lt;/script&gt; 结果： &lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;item,i in arr&quot;&gt;{{i}}=&gt;{{item}}&amp;nbsp;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ arr:[1,2,3,4,5] } }) &lt;/script&gt; 结果：2.迭代对象中的属性 &lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;item in arr&quot;&gt;{{item.id}}=&gt;{{item.name}}&amp;nbsp;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ arr:[ {id:1,name:&#39;ls1&#39;}, {id:2,name:&#39;ls2&#39;}, {id:2,name:&#39;ls3&#39;} ] } }) &lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;item,i in arr&quot;&gt;{{i}}=&gt;{{item.id}}=&gt;{{item.name}}&amp;nbsp;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ arr:[ {id:1,name:&#39;ls1&#39;}, {id:2,name:&#39;ls2&#39;}, {id:2,name:&#39;ls3&#39;} ] } }) &lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;val,key in obj&quot;&gt;{{key}}=&gt;{{val}}&amp;nbsp;&lt;/span&gt; &lt;!--可以有第三个值，索引--&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ obj:{ id:123456, name:&quot;zs&quot;, sex:&quot;M&quot; } } }) &lt;/script&gt; 3.迭代数字 迭代数字从1开始 &lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;count in 5&quot;&gt;{{count}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{} }) &lt;/script&gt; Vue条件语句v-if：每次都会重新创建或者删除元素v-show：不会重新进行对DOM删除或者创建，只是切换了元素的display:none的属性v-if有更高的切换消耗v-show有更高的初始渲染消耗，因此如果需要频繁切换v-show较好，如果运行条件不大可能改变v-if更好 &lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;hasinfor&quot;&gt;您已登陆&lt;/span&gt; &lt;!--v-else-if用于多重判断--&gt; &lt;span v-else=&quot;hasinfor&quot;&gt;请登录登陆&lt;/span&gt; &lt;span v-show=&quot;hasinfor&quot;&gt;您已登陆&lt;/span&gt; &lt;span v-show=&quot;!hasinfor&quot;&gt;请登录登陆&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data:{ hasinfor:false } }) &lt;/script&gt; Vue过滤器可被用作一些常见文本格式化，可在mustachc插值和v-bind表达式过滤器调用格式 {{name|过滤器名称}} 全局过滤器的使用 Vue.filter(&#39;过滤器名称&#39;,function(){}) 私有过滤器的使用 filters:{ 过滤器名称:function(){} } 例子： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{msg|msgFormat}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; Vue.filter(&#39;msgFormat&#39;,function(msg){ return msg.replace(&#39;邪恶&#39;,&#39;单纯&#39;) }) var vm = new Vue({ el: &quot;#app&quot;, data:{ msg:&quot;他是一个邪恶的男孩&quot; } }) &lt;/script&gt; /*****私有过滤器的使用方法 var vm = new Vue({ el: &quot;#app&quot;, data:{ msg:&quot;他是一个邪恶的男孩&quot; }, filters:{ msgFormat:function(msg){ return msg.replace(&#39;邪恶&#39;,&#39;单纯&#39;) } } }) *****/ 输出：他是一个单纯的男孩 Vue按键修饰符Vue 允许为 v-on 在监听键盘事件时添加按键修饰符 &lt;!--在输入框绑定回车事件submit--&gt; &lt;input v-on:keyup.enter=&quot;submit&quot;&gt; Vue 提供了绝大多数常用的按键码的别名 enter tab delete (捕获“删除”和“退格”键) esc space up down left right 可以通过全局 config.keyCodes 对象自定义按键修饰符别名 // 可以使用v-on:keyup.f1,112为f1的键码 Vue.config.keyCodes.f1 = 112 Vue自定义指令对普通 DOM 元素进行底层操作，这时候就会用到自定义指令 自定义指令使用方法： v-指令名称 全局自定义指令的注册 Vue.directive(&#39;指令名称&#39;,{ //第二个参数为一个对象，包括不同的钩子函数，常用bind,inserted,update bind:function(){}, inserted:function(){}, update:function(){} }) 局部自定义指令的注册 directives:{ 指令名称:{ bind:function(){}, inserted:function(){}, update:function(){} } } 例子： &lt;div id=&quot;app&quot;&gt; &lt;p v-color&gt;测试文字&lt;/p&gt; &lt;/div&gt; &lt;script&gt; Vue.directive(&#39;color&#39;,{ bind:function(el){ el.style.color=&quot;red&quot;;//el是直接对dom元素进行操作 } }) &lt;/script&gt; /*****私有指令的使用方法 var vm = new Vue({ el: &quot;#app&quot;, data:{}, directives:{ color:{ bind:function(el){ el.style.color=&quot;red&quot;; } } } }) *****/ 钩子函数|函数名称| 作用 ||–|–|| bind | 只调用一次，指令第一次绑定到元素时调用 || inserted | 被绑定元素插入父节点时调用 || update | 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前 || componentUpdated | 指令所在组件的 VNode 及其子 VNode 全部更新后调用|| unbind | 只调用一次，指令与元素解绑时调用| 钩子函数参数- el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 &lt;div id=&quot;app&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt; &lt;script&gt; Vue.directive(&#39;demo&#39;, { bind: function(el, binding){ el.innerHTML = &#39;name: &#39; + binding.name + &#39;&lt;br&gt;&#39; + &#39;value: &#39; + binding.value + &#39;&lt;br&gt;&#39; + &#39;expression: &#39; + binding.expression + &#39;&lt;br&gt;&#39; + &#39;argument: &#39; + binding.arg + &#39;&lt;br&gt;&#39; + &#39;modifiers: &#39; + JSON.stringify(binding.modifiers) + &#39;&lt;br&gt;&#39; } }) var vm = new Vue({ el: &quot;#app&quot;, data: { message:&quot;hello&quot; }, }) &lt;/script&gt; 输出结果： Vue监听属性可以通过 watch 来响应数据的变化格式： watch:{ 监听的属性:function (newvalue,oldvalue) {} } 例子: &lt;div id=&quot;app&quot;&gt; 请输入姓：&lt;input type=&quot;text&quot; v-model=&quot;fistname&quot; /&gt;&lt;br /&gt; 请输入名：&lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; /&gt;&lt;br /&gt; 姓名：&lt;span&gt;{{fullname}}&lt;/span&gt; &lt;p&gt;{{log}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, data:{ fistname:&#39;&#39;, lastname:&#39;&#39;, fullname:&#39;&#39;, log:&#39;&#39; }, watch:{ &#39;fistname&#39;:function () { this.fullname=this.fistname+this.lastname; }, &#39;lastname&#39;:function () { this.fullname=this.fistname+this.lastname; }, &#39;fullname&#39;:function (newname,oldname) { this.log=&#39;您的姓名由&#39;+oldname+&#39;改成&#39;+newname; }, } }) &lt;/script&gt; Vue计算属性计算属性关键词: computed计算属性的本质就是一个方法，只不过，在使用这些计算属性的时候，是把他们的名称直接当作属性使用，并不会当作方法可以使用 methods 来替代 computed，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。使用 computed 性能会更好，但不希望缓存，可以使用 methods 属性 var vue = new Vue({ el: &#39;#app&#39;, computed:{ } }) Vue生命周期生命周期钩子=生命周期函数=生命周期事件 图示： 钩子函数 生命周期钩子 详情 应用 beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用，不能访问到data以及methods等 初始化非响应式变量 created 实例已经创建完成之后被调用。可访问data以及methods等，未挂载DOM,不能访问$el 简单的ajax请求以及页面的初始化 beforeMount 在挂载开始之前被调用，可访问到$el mounted 挂载到实例上去之后调用该钩子 常用于获取VNode信息和操作，ajax请求 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前 更新之前访问现有的DOM，手动移除已添加的事件监听器 updated 虚拟 DOM 重新渲染和打补丁之后调用 避免在这个钩子函数中操作数据，可能陷入死循环 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 常用于销毁定时器、解绑全局事件、销毁插件对象等操作 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 Vue ajaxVue.js 2.0 版本推荐使用 axios 来完成 ajax 请求Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中 安装方法1.使用cdn &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 2.使用npm $ npm install axios get方法示例： &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, mounted() { axios .get(url)//url地址 .then(function(response){ console.log(response.data); })//.then为请求数据成功后的函数 .catch(function(error) { console.log(error); });//.catch为请求数据失败后的函数 } }) &lt;/script&gt; get传参 1.在url上拼接参数 axios .get(url+&#39;?key1=value1&amp;key2=value2&#39;) 2.使用params传参 axios .get(url,{ params:{ key1:value1, key2:value2 } }) post方法&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, mounted() { axios .post(url)//url地址 .then(function(response){ console.log(response.data); })//.then为请求数据成功后的函数 .catch(function(error) { console.log(error); });//.catch为请求数据失败后的函数 } }) &lt;/script&gt; post传参 axios .post(url,{ key1:value1,//第一个参数 key2:value2//第二个参数 }) axios API可以通过向 axios 传递相关配置来创建请求 &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, mounted() { axios({ method: &#39;get&#39;, url:url, params:{ key:value } })//config配置，具体见下文 .then(function(response){ console.log(response.data); })//.then为请求数据成功后的函数 .catch(function(error) { console.log(error); });//.catch为请求数据失败后的函数 } }) &lt;/script&gt; 请求方法别名在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 例如： &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, mounted() { axios .get(url,{ //此处对config里的参数进行配置 //与请求一起发送的 URL 参数 params:{ key=value }, //指定请求超时的毫秒数 timeout:1000, })//url地址 .then(function(response){ console.log(response.data); })//.then为请求数据成功后的函数 .catch(function(error) { console.log(error); });//.catch为请求数据失败后的函数 } }) &lt;/script&gt; axios响应结构 { // `data` 由服务器提供的响应 data: {}, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &quot;OK&quot;, // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 默认配置1.默认全局配置 axios.defaults.baseURL = 主目录url; 2.自定义的实例默认设置 var instance = axios.create({ baseURL: 主目录url, timeout:1000 }); instance .get(&#39;/下一级目录&#39;) //修改 instance.defaults.baseURL = url; config配置点击此处 Vue动画语法格式&lt;transtion&gt; &lt;!--变化的DOM--&gt; &lt;/transtion&gt; 过渡的类名即用相应类名的css控制变化前后以及变化的时长|类名| 作用 ||–|–|| v-enter | 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 || v-enter-active | 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数 || v-enter-to | 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除 || v-leave | 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除 || v-leave-active | 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 || v-leave-to | 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除 |***如果transition没有指定name属性的值，默认类名为上表的类名，即v-(如v-enter)，如果指定了name的值，则类名为：name的值-(如name=”fade”,类名为fade-enter)例子：css /*默认的transition*/ .v-enter,.v-leave-to{ opacity: 0; transform: translateX(100px); } .v-enter-active,.v-leave-active{ transition: all 0.8s linear; } /*指定name属性的transition*/ .fade-enter,.fade-leave-to{ opacity: 0; transform: translateY(100px); } .fade-enter-active,.fade-leave-active{ transition: all 1s linear; } html &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;h1变化&quot; @click=&quot;flag1=!flag1&quot;/&gt; &lt;transition&gt; &lt;h1 v-if=&quot;flag1&quot;&gt;这是一个可以变化的h1&lt;/h1&gt; &lt;/transtion&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;h2变化&quot; @click=&quot;flag2=!flag2&quot;/&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;h2 v-if=&quot;flag2&quot;&gt;这是一个可以变化的h2&lt;/h2&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, data:{ flag1:false, flag2:false } }) &lt;/script&gt; 自定义过渡类名自定义过渡的类名优先级高于普通的类名，这样就能很好的与第三方（如：animate.css）的动画库结合使用 enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) :duration用于设置过渡动画时间 &lt;transition :duration=&quot;800&quot;&gt;...&lt;/transition&gt; &lt;transition :duration=&quot;{ enter: 600, leave: 1000 }&quot;&gt;...&lt;/transition&gt; 例如： &lt;!--前面引入Animate.css动画库--&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;h1变化&quot; @click=&quot;show=!show&quot;/&gt; &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :duration=&quot;1000&quot; &gt; &lt;h1 v-if=&quot;show&quot;&gt;这是一个使用自定义动画的h1&lt;/h1&gt; &lt;/transtion&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, data:{ show:false, } }) &lt;/script&gt; JavaScript 钩子html &lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot; &gt; &lt;/transition&gt; 函数 作用 beforeEnter(el) el，表示要执行动画的DOM元素，是个原生的js对象，动画入场之前 function(el, done) 动画开始之后的样子，在这可以设置结束状态，done的起始就是afterEnter，done为afterEnter的引用 afterEnter(el) 动画完成之后调用 leave函数类似*在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。***推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响 小球移动例子： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;jump&quot; @click=&quot;show=!show&quot;/&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot; &gt; &lt;div v-if=&quot;show&quot; style=&quot;width: 20px;height: 20px;border-radius: 50%;background: red;&quot;&gt;&lt;/div&gt; &lt;/transtion&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, data:{ show:false, }, methods:{ beforeEnter:function(el){ el.style.transform=&quot;translate(0,0)&quot;; }, enter:function(el,done){ el.offsetWidth; //可以认为el.offsetWidth会强制动画刷新，不加没动画 el.style.transform=&quot;translate(150px,450px)&quot;; el.style.transition=&quot;all 1s ease&quot;; done(); }, afterEnter:function(el){ this.show=!this.show; } } }) &lt;/script&gt; 列表过渡1.在实现列表过渡的时候，如果需要过渡的元素是通过v-for循环渲染出来的，则使用transition-group包裹2.不同于 transition，transition-group会以一个真实元素呈现，默认为span，可以通过 tag 特性更换为其他元素3.内部元素总是需要提供唯一的 key 属性值 例子：随机在数组位置中插入一个数字以及随机减少一个数字css .num{ margin-right: 10px; display: inline-block; } .num-enter, .num-leave-to{ opacity: 0; transform: translateY(20px); } .num-enter-active, .num-leave-active { transition: all 1s linear; } html &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Add&quot; @click=&quot;add&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;remove&quot; @click=&quot;remove&quot;/&gt; &lt;transition-group name=&quot;num&quot; tag=&quot;div&quot;&gt; &lt;span class=&quot;num&quot; v-for=&quot;item in arr&quot; v-bind:key=&quot;item&quot;&gt;{{item}}&lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, data:{ arr:[1,2,3,4,5,6,7,8,9], nextnum:10//为了使key唯一,让增加的数字每次都不同,在9之后 }, methods:{ add:function(){ var index=Math.floor(Math.random() * this.arr.length); return this.arr.splice(index,0,this.nextnum++); }, remove:function(){ var index=Math.floor(Math.random() * this.arr.length); return this.arr.splice(index,1); } } }) &lt;/script&gt; 上述例子中，添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，为了解决这个问题，则添加下面代码 /*这两个类需要配合使用，才能让其他元素有动画*/ .num-move{ transition: all 1s linear; } .num-leave-active{ position: absolute; } 过渡模式transition的默认行为是进入和离开同时发生，可以通过vue提供的过渡模式让进入和离开分别进行格式： &lt;transitio mode=&quot;out-in&quot;&gt; &lt;/transition&gt; 模式 方式 in-out 新元素先进行过渡，完成之后当前元素过渡离开 out-in 当前元素先进行过渡，完成之后新元素过渡进入 组件过渡了解组件知识点击此处直接跳转 Vue组件组件可以扩展 HTML 元素，封装可重用的代码。组件化是从UI的角度进行划分，前端的组件化，方便UI组件的重用 全局组件注册格式： Vue.component(tagName, options) 调用组件的方式 &lt;tagName&gt;&lt;/tagName&gt; 如果为驼峰命名，则采用将大写改小写，两个单词用-分离例： &lt;div id=&quot;app&quot;&gt; &lt;com&gt;&lt;/com&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;com&#39;,{ template:&quot;&lt;h1&gt;这是由vue创建的第一个全局组件&lt;/h1&gt;&quot;, //通过template属性指定要展示的HTML结构 }) Vue.component(&#39;myCom&#39;,{ template:&quot;&lt;h1&gt;这是由vue创建的第二个全局组件&lt;/h1&gt;&quot;, //调用采用my-com的标签 }) var vue = new Vue({ el: &#39;#app&#39;, data:{} }) &lt;/script&gt; **需要注意的是，template属性指向的模板内容必须有且只有唯一的根元素 局部组件注册格式： components:{ tagName: options } 例子 &lt;div id=&quot;app&quot;&gt; &lt;my-com2&gt;&lt;/my-com2&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue({ el: &#39;#app&#39;, data:{}, components:{ myCom2:{ template:&quot;&lt;h1&gt;这是由vue创建的私有组件&lt;/h1&gt;&quot; } } }) &lt;/script&gt; 外部定义通过template标签可在外面定义的组件结构后调用 &lt;template id=&quot;t_com&quot;&gt; &lt;h1&gt;这是通过template元素在外面定义的组件结构&lt;/h1&gt; &lt;/template&gt; &lt;div id=&quot;app&quot;&gt; &lt;t-com&gt;&lt;/t-com&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;tCom&#39;,{ template:&#39;#t_com&#39; }) var vue = new Vue({ el: &#39;#app&#39;, data:{} }) &lt;/script&gt; 组件的数据和方法1.组件可以有自己的数据，但是组件中的数据必须为一个方法2.在方法的内部，必须返回一个对象3.调用方式和实例中的data一样例子：计数器 &lt;template id=&quot;counter&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; @click=&quot;add&quot;/&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;counter&#39;,{ template:&#39;#counter&#39;, data:function(){ return { count:0 } }, methods:{ add:function(){ this.count++ } } }) var vue = new Vue({ el: &#39;#app&#39;, data:{}, }) &lt;/script&gt; 父组件向子组件传值使用v-bind 动态绑定 props的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件，props值为只读 &lt;div id=&quot;app&quot;&gt; &lt;com v-bind:parentmsg=&quot;msg&quot;&gt;&lt;/com&gt; &lt;!--parentmsg通过props传递到父组件中被调用，传递的值为msg--&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;com&#39;,{ template:&quot;&lt;h1&gt;这是子组件and{{parentmsg}}&lt;/h1&gt;&quot;, props:[&#39;parentmsg&#39;], //只有通过props数组,子组件才可以调用传递过来的值 }) var vue = new Vue({ el: &#39;#app&#39;, data:{ msg:&quot;这是父组件的数据&quot; } }) &lt;/script&gt; 子组件向父组件传值使用 v-on 绑定自定义事件，使用 $emit(eventName) 触发事件 &lt;template id=&quot;com&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击子组件向父组件传值&quot; @click=&quot;myclick&quot;/&gt; &lt;/template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--通过v-on绑定子组件中触发的函数func,交给父组件中的show方法来处理，参数为子组件传递的参数--&gt; &lt;com v-on:func=&quot;show&quot;&gt;&lt;/com&gt; &lt;/div&gt; &lt;script&gt; //添加子组件的点击事件为myclick,通过myclick触发函数,后面跟要传递的值 Vue.component(&#39;com&#39;,{ template:&quot;#com&quot;, data(){ return{ childmsg:&quot;这是子组件的值&quot; } }, methods:{ myclick:function(){ this.$emit(&#39;func&#39;,this.childmsg) } } }) var vue = new Vue({ el: &#39;#app&#39;, methods:{ show:function(data){ console.log(data) } } }) &lt;/script&gt; 组件切换1.使用v-if/v-else进行显示和隐藏 &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=true&quot;&gt;登陆&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=false&quot;&gt;注册&lt;/a&gt; &lt;!--click.prevent阻止默认事件--&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else&gt;&lt;/register&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;login&#39;,{ template:&quot;&lt;h3&gt;登陆组件&lt;/h3&gt;&quot; }) Vue.component(&#39;register&#39;,{ template:&quot;&lt;h3&gt;注册组件&lt;/h3&gt;&quot; }) var vue = new Vue({ el: &#39;#app&#39;, data:{ flag:true }, }) &lt;/script&gt; 2.使用component来展示对应名称的组件，:is属性可以用来指定展示的组件名称，类型为字符串，所以用’ ‘ &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;cname=&#39;login&#39;&quot;&gt;登陆&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;cname=&#39;register&#39;&quot;&gt;注册&lt;/a&gt; &lt;!--click.prevent阻止默认事件--&gt; &lt;component :is=&quot;cname&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;login&#39;,{ template:&quot;&lt;h3&gt;登陆组件&lt;/h3&gt;&quot; }) Vue.component(&#39;register&#39;,{ template:&quot;&lt;h3&gt;注册组件&lt;/h3&gt;&quot; }) var vue = new Vue({ el: &#39;#app&#39;, data:{ cname:&#39;login&#39; }, }) &lt;/script&gt; 组件过渡 多个组件过渡不需要使用key属性例子：css .v-enter,.v-leave-to{ transform: translateY(20px); opacity: 0; } .v-enter-active,.v-leave-active{ transition: all 0.5s linear; } html &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;cname=&#39;login&#39;&quot;&gt;登陆&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;cname=&#39;register&#39;&quot;&gt;注册&lt;/a&gt; &lt;!--click.prevent阻止默认事件--&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;cname&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;login&#39;,{ template:&quot;&lt;h3&gt;登陆组件&lt;/h3&gt;&quot; }) Vue.component(&#39;register&#39;,{ template:&quot;&lt;h3&gt;注册组件&lt;/h3&gt;&quot; }) var vue = new Vue({ el: &#39;#app&#39;, data:{ cname:&#39;login&#39; }, }) &lt;/script&gt; Vue路由前端路由：主要通过URL中的hash(#号)来实现不同页面之间的切换，同时hash有个特点，http请求不包含hash相关的内容。这种通过hash改变来切换页面的方式称为前端路由 安装方法1.使用cdn &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; 2.使用npm npm install vue-router 基本使用1.创建一个路由对象，VueRouter var routerobj=new VueRouter() 2.在路由对象里配置路由规则，routes，每个规则都是一个对象。里面包含两个必须属性1)path，表示监听哪个路由地址。2)component，表示路由是前面所匹配到的path，则component对应哪个组件，component必须是一个模板对象，不能是组件引用的名称。 var routerobj=new VueRouter({ routes:[ {path:路由地址,component:组件模板对象} ] }) 3.将路由规则对象注册到vm实例上，用来监听URL地址的变化，然后展示对应组件的变化 var vue = new Vue({ el: &#39;#app&#39;, router:routerobj }) 4.router-view将路由规则匹配到的组件展示到页面 &lt;router-view&gt;&lt;/router-view&gt; 5.切换方式1)a标签 &lt;a href=&quot;#/路由地址&quot;&gt;&lt;/a&gt; 注意有#进行hash 2)router-link &lt;router-link to=&quot;/路由地址&quot;&gt;&lt;/router-link&gt; 例子 &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login={ template:&#39;&lt;h1&gt;登陆组件&lt;/h1&gt;&#39; } var register={ template:&#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39; } //创建一个路由对象 var routerobj=new VueRouter({ //配置路由规则 routes:[ //component必须是一个模板对象 {path:&#39;/&#39;,redirect:&#39;/login&#39;},//重定向，默认path为/login {path:&#39;/login&#39;,component:login}, {path:&#39;/register&#39;,component:register} ] }) var vue = new Vue({ el: &#39;#app&#39;, router:routerobj }) &lt;/script&gt; 点击默认URL和点击登陆时点击注册时注：可用redirect进行重定向，使默认的URL展示的指定路由地址 router-link设置1.router-link默认渲染成a标签，如需要渲染成其他标签，则在标签内添加tag属性，指向设置的标签 &lt;router-link to=&quot;/路由地址&quot; tag=&quot;li&quot;&gt;&lt;/router-link&gt; 2.设置选中样式1)默认选中路由标签的类名为router-link-active，只需修改这个类的样式，即可设置选中样式2)在路由对象中添加linkActiveClass属性，设置对应的类 var routerobj=new VueRouter({ routes:[], linkActiveClass:&#39;myClass&#39; }) 路由传参1.query方式不需要修改path属性，传参的格式为在连接地址后加?key=value，调用$router.query.key2.params方式在path属性后添加/:key，传参的格式为在连接地址后加/value，调用$router.params.key &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login?id=11&amp;name=hhh&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register/11/hh&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login={ template:&#39;&lt;h1&gt;登陆组件&lt;br/&gt;id:{{$route.query.id}}&lt;br/&gt;name:{{$route.query.name}}&lt;/h1&gt;&#39; } var register={ template:&#39;&lt;h1&gt;注册组件&lt;br/&gt;id:{{$route.params.id}}&lt;br/&gt;name:{{$route.params.name}}&lt;/h1&gt;&#39; } var routerobj=new VueRouter({ routes:[ {path:&#39;/login&#39;,component:login}, {path:&#39;/register/:id/:name&#39;,component:register} ] }) var vue = new Vue({ el: &#39;#app&#39;, router:routerobj }) &lt;/script&gt; 路由的嵌套在路由匹配规则中用children属性即可实现组件的嵌套 &lt;!-- 用户组件acc里面包含登陆注册组件以及相应的显示 --&gt; &lt;template id=&quot;acc&quot;&gt; &lt;div&gt; &lt;h1&gt;这里是用户界面&lt;/h1&gt; &lt;!-- 包含父组件路径 --&gt; &lt;router-link to=&quot;/acc/login&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/acc/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/acc&quot;&gt;用户界面&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login={ template:&#39;&lt;h1&gt;登陆组件&lt;/h1&gt;&#39; } var register={ template:&#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39; } var acc={ template:&#39;#acc&#39; } var routerobj=new VueRouter({ routes:[ { path:&#39;/acc&#39;, component:acc, //不需要/,否则将以根目录开头 children:[ {path:&#39;login&#39;,component:login}, {path:&#39;register&#39;,component:register} ] } ] }) var vue = new Vue({ el: &#39;#app&#39;, router:routerobj }) &lt;/script&gt; 命名视图为了同级展示多个视图，则使用命名视图，在路由配置中，使用components配置多个路由视图，name属性对应 router-view的name属性对应components配置对象的名字，如果 router-view 没有设置名字，那么默认为 default &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view name=&#39;a&#39;&gt;&lt;/router-view&gt; &lt;router-view name=&#39;b&#39;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var com1={ template:&#39;&lt;h1&gt;组件1&lt;/h1&gt;&#39; } var com2={ template:&#39;&lt;h1&gt;组件2&lt;/h1&gt;&#39; } var com3={ template:&#39;&lt;h1&gt;组件3&lt;/h1&gt;&#39; } var routerobj=new VueRouter({ routes:[ { path:&#39;/&#39;, components:{ default:com1, a:com2, b:com3 } } ] }) var vue = new Vue({ el: &#39;#app&#39;, router:routerobj }) &lt;/script&gt;","categories":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}],"tags":[],"keywords":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}]},{"title":"html+css实现多种动态相册","slug":"qd/1563698753","date":"2019-07-21T08:45:53.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/07/21/qd/1563698753/","link":"","permalink":"/2019/07/21/qd/1563698753/","excerpt":"","text":"电子相册原理：由a标签的锚点进行图片上的切换，左侧大图用verflow: hidden进行隐藏，右侧小图用overflow: scroll进行显示。HTML： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/ElectronAlbum.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;h1&gt;电子相册&lt;/h1&gt; &lt;ul class=&quot;list1&quot;&gt; &lt;li&gt;&lt;img src=&quot;../img/danji.jpg&quot; id=&quot;img1&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/dianwei.jpg&quot; id=&quot;img2&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/diaochan.jpg&quot; id=&quot;img3&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/lanlinwang.jpg&quot; id=&quot;img4&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/luban.jpg&quot; id=&quot;img5&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/zhaoyun.jpg&quot; id=&quot;img6&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/zhugeliang.jpg&quot; id=&quot;img7&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/kai.jpg&quot; id=&quot;img8&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;list2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#img1&quot;&gt;&lt;img src=&quot;../img/danji.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img2&quot;&gt;&lt;img src=&quot;../img/dianwei.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img3&quot;&gt;&lt;img src=&quot;../img/diaochan.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img4&quot;&gt;&lt;img src=&quot;../img/lanlinwang.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img5&quot;&gt;&lt;img src=&quot;../img/luban.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img6&quot;&gt;&lt;img src=&quot;../img/zhaoyun.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img7&quot;&gt;&lt;img src=&quot;../img/zhugeliang.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img8&quot;&gt;&lt;img src=&quot;../img/kai.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; CSS * { margin: 0; padding: 0; } body { background: #333; } li { list-style: none; } h1 { text-align: center; height: 50px; line-height: 50px; color: #FFFFFF; } .box{ width: 660px; height: 320px; margin: 200px auto; border: 5px solid white; box-shadow: 0px 0px 10px black; } .list1,.list2{ float: left; } .list1{ width: 480px; height: 270px; overflow: hidden; } .list2{ width: 180px; height: 270px; overflow: scroll; } .list1 img{ width: 480px; height: 270px; } .list2 img{ width: 160px; height: 90px; } 全屏背景切换原理：和电子相册类似用a标签进行图片的切换，设置图片原来的位置以及点击a标签后的:target属性，设置动画效果。HTML: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;FullPhoto&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/FullPhoto.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;../img/dianwei.jpg&quot; id=&quot;img1&quot;&gt; &lt;img src=&quot;../img/diaochan.jpg&quot; id=&quot;img2&quot;&gt; &lt;img src=&quot;../img/lanlinwang.jpg&quot; id=&quot;img3&quot;&gt; &lt;img src=&quot;../img/sunshangxiang.jpg&quot; id=&quot;img4&quot;&gt; &lt;img src=&quot;../img/luban.jpg&quot; id=&quot;img5&quot;&gt; &lt;/div&gt; &lt;div class=&quot;list&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#img1&quot;&gt;&lt;img src=&quot;../img/dianwei.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img2&quot;&gt;&lt;img src=&quot;../img/diaochan.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img3&quot;&gt;&lt;img src=&quot;../img/lanlinwang.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img4&quot;&gt;&lt;img src=&quot;../img/sunshangxiang.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#img5&quot;&gt;&lt;img src=&quot;../img/luban.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; CSS: * { margin: 0; padding: 0; } .box { width: 100%; height: 100%; } .box img { width: 100%; height: 100%; position: fixed; transition: all 1s linear; } .list { position: absolute; z-index: 999; width: 1000px; height: auto; bottom: 20px; left: 0; right: 0; margin: auto; } .list li { list-style: none; width: 130px; height: 130px; border: 5px solid lightskyblue; float: left; margin-left: 60px; overflow: hidden; border-radius: 50%; } .list li img { width: 200%; } .box img:nth-child(1) { opacity: 0; left: -100%; } .box img:nth-child(1):target { z-index: 1; opacity: 1; left: 0; } .box img:nth-child(2) { top: -100%; } .box img:nth-child(2):target { z-index: 1; transform: rotate(360deg); top: 0; } .box img:nth-child(3) { opacity: 0; right: -100%; } .box img:nth-child(3):target { z-index: 1; opacity: 1; right: 0; } .box img:nth-child(4) { bottom: -100%; } .box img:nth-child(4):target { z-index: 1; transform: rotate(360deg); bottom: 0; } .box img:nth-child(5) { opacity: 0; } .box img:nth-child(5):target { z-index: 1; opacity: 1; transform: rotate(360deg); } 照片墙原理：利用悬浮属性，使鼠标悬浮在上面的图片进行相应的变化版本1：HTML: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;PhotoWall1&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/PhotoWall1.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;../img/danji.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/dianwei.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/diaochan.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/sunshangxiang.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/sunwukong.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/luban.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/lanlinwang.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/kai.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/donghuang.jpg&quot; &gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; CSS: * { margin: 0; padding: 0; } body { background-color: #333; } ul { width: 1020px; height: 600px; border: white solid 5px; margin: 60px auto; box-shadow: 0px 0px 10px #ccc; } li { width: 320px; height: 180px; list-style: none; float: left; margin: 10px; /* x y 扩散程度 阴影颜色*/ box-shadow: 0px 0px 10px white; } img { width: 100%; height: 100%; } img:hover { width: 150%; height: 150%; position: relative; top: -40px; left: -40px; } 版本2:HTML: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;PhotoWall2&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/PhotoWall2.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;../img/danji.jpg&quot;&gt; &lt;img src=&quot;../img/dianwei.jpg&quot;&gt; &lt;img src=&quot;../img/diaochan.jpg&quot;&gt; &lt;img src=&quot;../img/sunshangxiang.jpg&quot;&gt; &lt;img src=&quot;../img/sunwukong.jpg&quot;&gt; &lt;img src=&quot;../img/luban.jpg&quot;&gt; &lt;img src=&quot;../img/lanlinwang.jpg&quot;&gt; &lt;img src=&quot;../img/kai.jpg&quot;&gt; &lt;img src=&quot;../img/donghuang.jpg&quot; &gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; CSS: * { margin: 0; padding: 0; } body { background: url(../img/wbg.png); } .box{ width: 1000px; margin: 0px auto; margin-top: 100px; } .box img { width: 320px; height: 180px; border: 5px solid azure; box-shadow: -10px -10px 10px black; transition: all 0.3s linear; } img:nth-child(odd) { transform: rotate(20deg); } img:nth-child(even) { transform: rotate(-20deg); } img:hover { transform: scale(1.3); position: relative; z-index: 2; } 百叶窗原理：当鼠标悬浮在ul标签上，所有li标签变小，悬浮的li标签变大，添加css变化动画HTML: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;WindowShades&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/WindowShades.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;../img/danji.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/dianwei.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/diaochan.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/kai.jpg&quot; &gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../img/lanlinwang.jpg&quot; &gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; CSS: *{ margin: 0; padding: 0; } body{ background: url(../img/wbg.png); } .box{ width: 800px; height: 360px; margin: 200px auto; /*溢出部分隐藏*/ overflow: hidden; } .box img{ width: 640px; height: 360px; } li{ list-style: none; width: 155px; height: 360px; float: left; border-left: 5px solid white; box-shadow: -5px 0px 10px black; transition: all 0.5s linear; } /*鼠标悬浮在ul上，让ul变小*/ .box ul:hover li{ width: 35px; } /*鼠标悬浮到某个li上，让li变大*/ .box ul li:hover{ width: 635px; } 3d照片墙原理：将图片以绝对定位的方式放在父容器内(目的是使图片重叠在一起)，将每张图片旋转对应的角度(360°均分)，向z轴平移适合的距离。类似于一群人想要排成一个圆圈，则需要每个人平均转向不同的方向，然后向前走出一段距离。向父容器添加旋转动画，使所有照片旋转起来。HTML: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;3dPhoto&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/3dPhoto.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;show&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;../img/zhugeliang.jpg&quot; &gt; &lt;img src=&quot;../img/sunwukong.jpg&quot; &gt; &lt;img src=&quot;../img/diaochan.jpg&quot; &gt; &lt;img src=&quot;../img/libai.jpg&quot; &gt; &lt;img src=&quot;../img/zhaoyun.jpg&quot; &gt; &lt;img src=&quot;../img/donghuang.jpg&quot; &gt; &lt;img src=&quot;../img/dianwei.jpg&quot; &gt; &lt;img src=&quot;../img/kai.jpg&quot; &gt; &lt;img src=&quot;../img/lanlinwang.jpg&quot; &gt; &lt;img src=&quot;../img/sunshangxiang.jpg&quot; &gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; CSS: * { margin: 0; padding: 0; } body { background: url(../img/wbg.png); } .box { width: 320px; height: 200px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; transform-style: preserve-3d; animation: im 20s linear infinite; } .box img { width: 100%; height: 100%; position: absolute; } @keyframes im{ 0% { transform: rotateY(0deg) rotateX(10deg); } 25% { transform: rotateY(90deg) rotateX(-10deg); } 50% { transform: rotateY(180deg) rotateX(10deg); } 75% { transform: rotateY(270deg) rotateX(-10deg); } 100% { transform: rotateY(360deg) rotateX(10deg); } } /*10张图片3d变换*/ .box img:nth-child(1) { transform: rotateY(0deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(2) { transform: rotateY(36deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(3) { transform: rotateY(72deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(4) { transform: rotateY(108deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(5) { transform: rotateY(144deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(6) { transform: rotateY(180deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(7) { transform: rotateY(216deg) translateZ(600px); backface-visibility:visible; } .box img:nth-child(8) { transform: rotateY(252deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(9) { transform: rotateY(288deg) translateZ(600px); backface-visibility: visible; } .box img:nth-child(10) { transform: rotateY(324deg) translateZ(600px); backface-visibility: visible; } 立方体相册原理：将ul下6个li标签进行绝对定位，6个li标签分别转向6个方向，向Z轴的两个方向扩展立方体边长的一半。HTML: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;cube&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/cube.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; CSS: * { margin: 0; padding: 0; } body { background: #333; } ul { width: 300px; height: 300px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; /*3d空间*/ transform-style: preserve-3d; animation: box 20s linear infinite; } @keyframes box { /*3d旋转 x y z deg*/ from { transform: rotate3d(0, 0, 0, 0deg); } to { transform: rotate3d(1, 1, 1, 360deg); } } li { width: 300px; height: 300px; list-style: none; border: 1px solid black; position: absolute; opacity: 0.8; box-shadow: 0px 0px 10px white; } li:nth-child(1) { background: url(../img/danji.jpg); background-position: center; background-size: cover; transform: translateZ(150px); } /*后*/ li:nth-child(2) { background: url(../img/donghuang.jpg); background-position: center; background-size: cover; transform: translateZ(-150px); } /*左*/ li:nth-child(3) { background: url(../img/luban.jpg); background-position: center; background-size: cover; transform: rotateY(90deg) translateZ(-150px); } /*右*/ li:nth-child(4) { background: url(../img/libai.jpg); background-position: center; background-size: cover; transform: rotateY(90deg) translateZ(150px); } /*上*/ li:nth-child(5) { background: url(../img/kai.jpg); background-position: center; background-size: cover; transform: rotateX(90deg) translateZ(150px); } li:nth-child(6) { background: url(../img/sunwukong.jpg); background-position: center; background-size: cover; transform: rotateX(90deg) translateZ(-150px); } ul:hover { animation-play-state: paused; } 代码GitHub","categories":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}],"tags":[],"keywords":[{"name":"qd","slug":"qd","permalink":"/categories/qd/"}]},{"title":"PHP接口实战教程——PHP+Mysql+ajax实现分页查询接口","slug":"ht/1560073278","date":"2019-06-09T09:41:18.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/06/09/ht/1560073278/","link":"","permalink":"/2019/06/09/ht/1560073278/","excerpt":"","text":"知识预备Mysql知识分页的本质就是在查询记录中选择I-J条记录 limit M offset Nlimit N,M M pageSize 页面上每页展示的格式N pageSize*(pageIndex-1)当offset的N超过数据集的总量，会返回一个空的数据集 大量数据查询随着N值越来越大，查询的效率越来越低解决方法：1.科学的建立索引2.查询步骤一分为二 php操作数据库详细点击这里 原生ajax操作1.new一个request实例2.http请求状态变化3.发送请求 //new一个request实例 var request = new XMLHttpRequest(); //http请求状态变化 request.onreadystatechange = function() { //解析已经完成 if(request.readyState === 4) { //服务器状态码 if(request.status !== 200) { console.log(request.responseText); } else { console.log(request.responseText); } } } //发送请求 request.open(&#39;GET&#39;, &quot;test.php&quot;); //request.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); request.send(); 后端接口开发数据准备用excel生成一个含用户名(从uer001-uer200)，密码(随机6位数)，年龄(10-60岁)，性别的表，将其转换为csv保存(文件-另存为-选择csv（逗号分隔）)。若存在中文则将csv用记事本打开，另存为，选择编码格式为UTF-8。 打开phpmyadmin建立名为MyDB的数据库以及名为user的数据表(id主键,password,age,sex)导入整个csv 接口数据结构设置url：http://127.0.0.1/phpmysql/php/app.phpmethod：GETrequst： 参数名 必选 类型 说明 pageSize 否 int 每页展示的数据量,默认为10 pageIndex 是 int 第几页的数据 response { &quot;code&quot;: 0, &quot;message&quot;: &quot;Success&quot;, &quot;info&quot;: { &quot;count&quot;: &quot;200&quot;, &quot;totalPage&quot;: 20, &quot;data&quot;: [{ &quot;id&quot;: &quot;user001&quot;, &quot;password&quot;: &quot;997320&quot;, &quot;age&quot;: 27, &quot;sex&quot;: &quot;女&quot; }] } } code说明 0查询成功 1数据库连接失败 2未传入pageIndex 3未传入任何数据 接口类设置1.类名：app2.成员变量:$conn3.成员函数: 函数名 作用 __construct 构造函数，连接数据库 run 接口运行函数 pagination 查询操作 getCount 计算数据总量 returnSuccessData 返回正确的结果 returnData 返回所有的结果 后端代码&lt;?php class app{ private $conn; /** * app constructor. */ public function __construct() { // 创建连接 $this-&gt;conn = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;,&quot;mydb&quot;); //防止中文乱码 $this-&gt;conn-&gt;query(&quot;SET NAMES UTF8&quot;); //返回数据库连接错误 if ($this-&gt;conn-&gt;connect_error) { return $this-&gt;returnData(1,$this-&gt;conn-&gt;connect_error); } } /** * 接口运行 * @return false|string */ public function run(){ if(is_array($_GET)&amp;&amp;count($_GET)&gt;0)//先判断是否通过get传值了 { if(isset($_GET[&quot;pageIndex&quot;]))//是否存在&quot;pageIndex&quot;的参数 { $pageSize=$_GET[&#39;pageSize&#39;] ?? 10;//设置默认值为10 $pageIndex=$_GET[&#39;pageIndex&#39;]; $data=$this-&gt;pagination($pageSize,$pageIndex);//调用分页函数 $count=$this-&gt;getCount();//调用计算总数的函数 $totalPage=ceil($count/$pageSize);//计算总页数 $info=[ &#39;count&#39;=&gt;$count, &#39;totalPage&#39;=&gt;$totalPage, &#39;data&#39;=&gt;$data, ];//数据装入 return $this-&gt;returnSuccessData($info);//返回正确结果 }else{ return $this-&gt;returnData(2,&#39;未传入pageIndex&#39;); } }else{ return $this-&gt;returnData(3,&#39;未传入任何值&#39;); } } /** * 查询操作 * @param $pageSize * @param $pageIndex * @return array */ private function pagination($pageSize, $pageIndex){ $result=[]; //防sql注入 $stmt=$this-&gt;conn-&gt;prepare(&quot;SELECT * FROM `user` LIMIT ? OFFSET ?&quot;); $page=$pageSize*($pageIndex-1); $stmt-&gt;bind_param(&quot;ii&quot;, $pageSize, $page); $stmt-&gt;execute(); $data = $stmt-&gt;get_result(); //将获取的结果装入数组 while ($row = $data-&gt;fetch_assoc()){ array_push($result,$row); } return $result; } /** * 得到总条数 * @return mixed */ private function getCount(){ $result=$this-&gt;conn-&gt;query(&quot;SELECT count(id) id FROM `user`&quot;); $row = $result-&gt;fetch_assoc(); return $row[&#39;id&#39;]; } /** * 返回正确的结果数据 * @param $data * @return false|string */ private function returnSuccessData($data){ $content=[ &#39;code&#39;=&gt;0, &#39;message&#39;=&gt;&#39;Success&#39;, &#39;info&#39;=&gt;$data, ]; $this-&gt;conn-&gt;close(); return json_encode($content); } /** *返回一个通用的结果 * @param $code * @param $message * @param array $data * @return false|string */ private function returnData($code,$message,$data=[]){ $content=[ &#39;code&#39;=&gt;$code, &#39;message&#39;=&gt;$message, &#39;info&#39;=&gt;$data, ]; $this-&gt;conn-&gt;close(); return json_encode($content); } } $app=new app(); $re=$app-&gt;run(); echo $re; ?&gt;","categories":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}],"tags":[],"keywords":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}]},{"title":"PHP数据库——PHP学习笔记（四）","slug":"ht/1559613283","date":"2019-06-04T01:54:43.000Z","updated":"2020-06-11T02:57:18.369Z","comments":true,"path":"2019/06/04/ht/1559613283/","link":"","permalink":"/2019/06/04/ht/1559613283/","excerpt":"","text":"面向对象MySQLi类 MySQL连接创建mysqli对象，用对象中的close方法关闭连接 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password); // 检测连接 if ($conn-&gt;connect_error) { die(&quot;连接失败: &quot; . $conn-&gt;connect_error); } echo &quot;连接成功&quot; $conn-&gt;close() ?&gt; 建立数据表插入数据对象中的query方法创建数据库 $sql = &quot;CREATE DATABASE myDB2&quot;; if ($conn-&gt;query($sql) TRUE) { echo &quot;数据库创建成功&quot;; } else { echo &quot;Error creating database: &quot; . $conn-&gt;error; } 建表以及插入数据 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; $dbname=&quot;myDB1&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password,$dbname); // 检测连接 if ($conn-&gt;connect_error) { die(&quot;连接失败: &quot; . $conn-&gt;connect_error); } // 创建数据库 $sql=&quot;CREATE TABLE `mydb1`.`user` ( `id` VARCHAR(10) NOT NULL , `name` VARCHAR(10) NOT NULL , `age` INT NOT NULL , PRIMARY KEY (`id`)) ENGINE = MyISAM&quot;; if($conn-&gt;query($sql)){ echo &quot;user表创建成功&quot;.&quot;&lt;br /&gt;&quot;; //插入数据库操作 $sql=&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (&#39;12356&#39;, &#39;Bob&#39;, &#39;10&#39;)&quot;; if($conn-&gt;query($sql)){ echo &quot;插入数据库成功&quot;.&quot;&lt;br /&gt;&quot;; }else{ echo &quot;插入数据失败&quot;.$conn-&gt;error.&quot;&lt;br /&gt;&quot;; } //插入多条数据 $sql=&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (&#39;12385&#39;, &#39;Rose&#39;, &#39;15&#39;);&quot;; $sql.=&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (&#39;12366&#39;, &#39;Json&#39;, &#39;15&#39;)&quot;; if($conn-&gt;multi_query($sql)){ echo &quot;插入数据库成功&quot;.&quot;&lt;br /&gt;&quot;; }else{ echo &quot;插入数据失败&quot;.$conn-&gt;error.&quot;&lt;br /&gt;&quot;; } } else{ echo &quot;创建错误&quot;.$conn-&gt;error.&quot;&lt;br /&gt;&quot;; } $conn-&gt;close(); ?&gt; 数据预处理1.创建sql模板，其中的值用问号代替2.bind_param()，第一个参数为列预处理，i-整形，d-双精度浮点型，s-字符串，b-二进制大对象3.execute()，插入4.关闭模板 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; $dbname=&quot;myDB1&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password,$dbname); // 检测连接 if ($conn-&gt;connect_error) { die(&quot;连接失败: &quot; . $conn-&gt;connect_error); } // 创建数据库 $sql=&quot;CREATE TABLE `mydb1`.`user` ( `id` VARCHAR(10) NOT NULL , `name` VARCHAR(10) NOT NULL , `age` INT NOT NULL , PRIMARY KEY (`id`)) ENGINE = MyISAM&quot;; if($conn-&gt;query($sql)){ echo &quot;user表创建成功&quot;.&quot;&lt;br /&gt;&quot;; //插入数据库操作 $stmt=$conn-&gt;prepare(&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (?, ?, ?)&quot;); $stmt-&gt;bind_param(&quot;ssi&quot;, $id, $name, $age); $id = &quot;12356&quot;; $name = &quot;Bob&quot;; $age = &quot;10&quot;; $stmt-&gt;execute(); $id = &quot;12385&quot;; $name = &quot;Rose&quot;; $age = &quot;15&quot;; $stmt-&gt;execute(); $id = &quot;12366&quot;; $name = &quot;Json&quot;; $age = &quot;15&quot;; $stmt-&gt;execute(); echo &quot;插入成功&quot;; $stmt-&gt;close(); $conn-&gt;close(); } else{ echo &quot;创建错误&quot;.$conn-&gt;error.&quot;&lt;br /&gt;&quot;; } ?&gt; 数据的删除，更新类似，只是sql语句不同 读取数据 1.将查询结果的语句赋值给 $result 2.函数 num_rows() 判断返回的数据，行数 3.函数 fetch_assoc() 函数从结果集中取得一行作为关联数组 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; $dbname=&quot;myDB1&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // Check connection if ($conn-&gt;connect_error) { die(&quot;连接失败: &quot; . $conn-&gt;connect_error); } $sql = &quot;SELECT id, name, age FROM user&quot;; $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) { // 输出数据 while($row = $result-&gt;fetch_assoc()) { echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - Name: &quot; . $row[&quot;name&quot;]. &quot; - age: &quot; . $row[&quot;age&quot;]. &quot;&lt;br&gt;&quot;; } }else{ echo &quot;0 结果&quot;; } $conn-&gt;close(); ?&gt; 数据的查询类似，只是sql语句不同 面向过程MySQLi 函数 MySQL连接 mysqli_connect(host,username,password,dbname,port,socket); 参数 描述 host 可选。规定主机名或 IP 地址 username 可选。规定 MySQL 用户名 password 可选。规定 MySQL 密码 dbname 可选。规定默认使用的数据库 port 可选。规定尝试连接到 MySQL 服务器的端口号。 socket 可选。规定 socket 或要使用的已命名 pipe 关闭链接 mysqli_close() &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; // 创建连接 $conn = mysqli_connect($servername, $username, $password); // 检测连接 if (!$conn) { die(&quot;Connection failed: &quot; . mysqli_connect_error()); } echo &quot;连接成功&quot;; //关闭链接 mysqli_close($conn); ?&gt; 建立数据表插入数据mysqli_query() 函数执行某个针对数据库的查询 mysqli_query(connection,query,resultmode); 参数 描述 connection 必需。规定要使用的 MySQL 连接 query 必需，规定查询字符串 resultmode 可选。一个常量 MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个)MYSQLI_STORE_RESULT（默认） 创建数据库 $sql = &quot;CREATE DATABASE myDB2&quot;; if (mysqli_query($conn, $sql)) { echo &quot;数据库创建成功&quot;; } else { echo &quot;Error creating database: &quot; . mysqli_error($conn); } 建表以及插入数据 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; $dbname=&quot;myDB2&quot;; // 创建连接 $conn = mysqli_connect($servername, $username, $password,$dbname); // 检测连接 if (!$conn) { die(&quot;连接失败: &quot; . mysqli_connect_error()); } // 创建数据库 $sql=&quot;CREATE TABLE `mydb2`.`user` ( `id` VARCHAR(10) NOT NULL , `name` VARCHAR(10) NOT NULL , `age` INT NOT NULL , PRIMARY KEY (`id`)) ENGINE = MyISAM&quot;; if (mysqli_query($conn, $sql)){ $sql=&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (&#39;12356&#39;, &#39;Bob&#39;, &#39;10&#39;)&quot;; if (mysqli_query($conn, $sql)) { echo &quot;插入数据库成功&quot;.&quot;&lt;br /&gt;&quot;; } else { echo &quot;插入数据失败&quot;. mysqli_error($conn).&quot;&lt;br /&gt;&quot;; } $sql=&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (&#39;12385&#39;, &#39;Rose&#39;, &#39;15&#39;);&quot;; $sql.=&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (&#39;12366&#39;, &#39;Json&#39;, &#39;15&#39;)&quot;; if (mysqli_multi_query($conn, $sql)) { echo &quot;插入数据库成功&quot;.&quot;&lt;br /&gt;&quot;; } else { echo &quot;插入数据失败&quot;. mysqli_error($conn).&quot;&lt;br /&gt;&quot;; } } else{ echo &quot;创建错误&quot;. mysqli_error($conn); } mysqli_close($conn); ?&gt; 数据预处理 1.创建sql模板 2.为 mysqli_stmt_prepare() 初始化 statement 对象 3.mysqli_stmt_prepare(,)预处理语句 4.mysqli_stmt_bind_param()绑定参数 5.mysqli_stmt_execute()插入语句 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; $dbname=&quot;myDB2&quot;; // 创建连接 $conn = mysqli_connect($servername, $username, $password,$dbname); // 检测连接 if (!$conn) { die(&quot;连接失败: &quot; . mysqli_connect_error()); } // 创建数据库 $sql=&quot;CREATE TABLE `mydb2`.`user` ( `id` VARCHAR(10) NOT NULL , `name` VARCHAR(10) NOT NULL , `age` INT NOT NULL , PRIMARY KEY (`id`)) ENGINE = MyISAM&quot;; if (mysqli_query($conn, $sql)){ $sql=&quot;INSERT INTO `user` (`id`, `name`, `age`) VALUES (?, ?, ?)&quot;; // 为 mysqli_stmt_prepare() 初始化 statement 对象 $stmt = mysqli_stmt_init($conn); //预处理语句 if (mysqli_stmt_prepare($stmt, $sql)) { // 绑定参数 mysqli_stmt_bind_param($stmt, &#39;ssi&#39;, $id, $name, $age); // 设置参数并执行 $id = &quot;12356&quot;; $name = &quot;Bob&quot;; $age = &quot;10&quot;; mysqli_stmt_execute($stmt); $id = &quot;12385&quot;; $name = &quot;Rose&quot;; $age = &quot;15&quot;; mysqli_stmt_execute($stmt); $id = &quot;12366&quot;; $name = &quot;Json&quot;; $age = &quot;15&quot;; mysqli_stmt_execute($stmt); echo &quot;插入成功&quot;; } } else{ echo &quot;创建错误&quot;. mysqli_error($conn); } mysqli_close($conn); ?&gt; 读取数据同面向对象 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;&quot;; $dbname=&quot;myDB2&quot;; // 创建连接 $conn = mysqli_connect($servername, $username, $password, $dbname); // Check connection if (!$conn) { die(&quot;连接失败: &quot; . mysqli_connect_error()); } $sql = &quot;SELECT id, name, age FROM user&quot;; $result = mysqli_query($conn, $sql); if (mysqli_num_rows($result) &gt; 0) { // 输出数据 while($row = mysqli_fetch_assoc($result)) { echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - Name: &quot; . $row[&quot;name&quot;]. &quot; - age: &quot; . $row[&quot;age&quot;]. &quot;&lt;br&gt;&quot;; } } else { echo &quot;0 结果&quot;; } mysqli_close($conn); ?&gt;","categories":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}],"tags":[],"keywords":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}]},{"title":"Wamp安装与配置","slug":"qt/1560958994","date":"2019-06-04T01:54:43.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/06/04/qt/1560958994/","link":"","permalink":"/2019/06/04/qt/1560958994/","excerpt":"","text":"wamp下载点击进入官网点击导航栏的DOWNLORD或者将主页拉到最下面根据自己的电脑选择32位或者64位的版本或者点击SourceForge进行选择版本进行下载 Wamp安装 选择安装路径这里以D盘为例 等待安装完成 安装完成后选择浏览器，这里选择谷歌 Wamp配置中文修改右击任务栏图标，选择language选择chinese 自定义网站根目录左击任务栏图标，选择Apache下的httpd.conf用ctrl+f搜索DocumentRoot，将下面里面的路径改为自己制定的路径保存，我这选择E:\\WebProject 同样选择Apach下httpd-vhosts.conf，将路径修改保存在安装目录下选择wampmanager.ini用记事本打开，搜索menu.left，修改名字和目录同样在安装目录下选择wampmanager.tpl用记事本打开，搜索第二个menu.left，修改名字和目录重启所有服务。至此，本地服务器就搭建好了，如需更多操作，可继续阅读下文。 多站点配置选择Apach下httpd-vhosts.conf，添加下面代码ServerName为服务器名字DocumentRoot为访问的文件夹 &lt;VirtualHost *:80&gt; ServerName test01.com DocumentRoot &quot;E:\\WebProject\\test1&quot; &lt;/VirtualHost&gt; 修改DNS（hosts）文件(C:\\Windows\\System32\\drivers\\etc\\hosts)添加如下内容：127.0.0.1 test01.com即可通过test01.com这个域名访问资源 允许外网访问1.左击任务栏图标，选择Apache下的httpd.conf搜索Directory &lt;Directory /&gt; AllowOverride none Require all granted &lt;/Directory&gt; 改为 &lt;Directory /&gt; AllowOverride none #Require all denied Require all granted &lt;/Directory&gt; 搜索onlineoffline #onlineoffline tag - don&#39;t remove Require local 改为 #onlineoffline tag - don&#39;t remove Require local Require all granted 2.左击任务栏图标，选择Apache下的httpd-vhosts.conf在Require local下加上Require all granted 修改默认端口号左击任务栏图标，选择Apache下的httpd.conf搜索80 #Listen 12.34.56.78:80 Listen 0.0.0.0:80 Listen [::0]:80 改为端口号8080 #Listen 12.34.56.78:8080 Listen 0.0.0.0:8080 Listen [::0]:8080 继续搜索 ServerName localhost:80 改为 ServerName localhost:8080 但是在此时发现phpMyAdmin和虚拟主机无法直接启动打开wamp目录下wampmanager.tpl Type: item; Caption: &quot;${w_localhost}&quot;; Action: run; FileName: &quot;${c_navigator}&quot;; Parameters: &quot;${c_edge}http://localhost${UrlPort}/&quot;; Glyph: 27 ${SupportDBMS}${phmyadMenu}Type: item; Caption: &quot;${w_phpmyadmin} ${phpmyadminVersion}&quot;; Action: run; FileName: &quot;${c_navigator}&quot;; Parameters: &quot;${c_edge}http://localhost${UrlPort}/phpmyadmin/&quot;; Glyph: 28 ${SupportDBMS}${adminerMenu}Type: item; Caption: &quot;Adminer ${adminerVersion}&quot;; Action: run; FileName: &quot;${c_navigator}&quot;; Parameters: &quot;${c_edge}http://localhost${UrlPort}/adminer/&quot;; Glyph: 28 将url的localhost后面添加:8080的端口号(3个) ${UrlPort} Type: item; Caption: &quot;${w_localhost}&quot;; Action: run; FileName: &quot;${c_navigator}&quot;; Parameters: &quot;http://localhost:8080/&quot;; Glyph: 27 ${SupportDBMS}${phmyadMenu}Type: item; Caption: &quot;${w_phpmyadmin} ${phpmyadminVersion}&quot;; Action: run; FileName: &quot;${c_navigator}&quot;; Parameters: &quot;http://localhost:8080/phpmyadmin/&quot;; Glyph: 28 ${SupportDBMS}${adminerMenu}Type: item; Caption: &quot;Adminer ${adminerVersion}&quot;; Action: run; FileName: &quot;${c_navigator}&quot;; Parameters: &quot;http://localhost:8080/adminer/&quot;; Glyph: 28","categories":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}],"tags":[],"keywords":[{"name":"qt","slug":"qt","permalink":"/categories/qt/"}]},{"title":"PHP进阶知识——PHP学习笔记（三）","slug":"ht/1559479981","date":"2019-06-02T12:53:01.000Z","updated":"2020-06-11T02:57:18.370Z","comments":true,"path":"2019/06/02/ht/1559479981/","link":"","permalink":"/2019/06/02/ht/1559479981/","excerpt":"","text":"多维数组一个数组中的值可以是另一个数组，此数组的值也可以是一个数组，照此，可以创建二维或者三维数组 &lt;?php $arr1=array( $arrch1=array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;), $arrch2=array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;), $arrch3=array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;) ); print_r($arr1);//print_r array，将会按照一定格式显示键和元素 ?&gt; 输出结果: Array ( [0] =&gt; Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 ) [1] =&gt; Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 ) [2] =&gt; Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 ) ) 日期date() 函数用于格式化时间/日期 string date ( string \\$format [, int \\$timestamp ] ) 参数 描述 format 必需。规定时间戳的格式 timestamp 必需。规定时间戳的格式 &lt;?php echo date(&quot;y/m/d&quot;,strtotime(&quot;2012-5-6&quot;)).&quot;&lt;br /&gt;&quot;;//strtotime为获取时间戳 echo date(&quot;y-m-d&quot;).&quot;&lt;br /&gt;&quot;;//默认为当前时间戳 time() ?&gt; 输出结果 19/05/06 19-06-02 详细参数 文件打开文件 file_exists() 检查文件和目录是否存在，返回布尔值 fopen() 第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件无法打开文件则返回false 模式 描述 r 只读。在文件的开头开始 r+ 读/写。在文件的开头开始 w 只写。打开并清空文件的内容；如果文件不存在，则创建新文件 w+ 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件 a 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件 a+ 读/追加。通过向文件末尾写内容，来保持文件内容 x 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误 x+ 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误 关闭文件 fclose() &lt;?php $file = fopen(&quot;test.txt&quot;,&quot;r&quot;) fclose($file); ?&gt; 文件操作 函数 说明 fgets() 函数用于从文件中逐行读取文件,在调用该函数之后，文件指针会移动到下一行 getc() 函数用于从文件中逐字符地读取文件,在调用该函数之后，文件指针会移动到下一个字符 feof() 函数检测是否已到达文件末尾（EOF）,写状态下不可用 fwrite()/fput() 写入文件，可选length参数，出现错误返回false &lt;?php $filename=&quot;test.txt&quot;; if(file_exists($filename)){ $file=fopen($filename,&#39;r+&#39;); if($file){ fwrite($file,&quot;Hello World&quot;,5); }else{ echo &quot;文件无法打开&quot;; } }else{ echo &quot;文件不存在&quot;; } ?&gt; test.txt内容：Hello Filesystem 函数 文件上传前端代码1.form的enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”2.input 标签的 type=”file” 属性规定了应该把输入作为文件来处理 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html 后端代码1.创建上传脚本全局数组 $_FILES，第一个参数是表单的 input name，第二个下标 全局数组 含义 $_FILES[“file”][“name”] 上传文件的名称 $_FILES[“file”][“type”] 上传文件的类型 $_FILES[“file”][“size”] 上传文件的大小，以字节计 $_FILES[“file”][“tmp_name”] 存储在服务器的文件的临时副本的名称 $_FILES[“file”][“error”] 由文件上传导致的错误代码 if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) { echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;; } else { echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; } 2.上传限制用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB $allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;);//设置允许上传的扩展名 $temp = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]);//explode()将字符串分解成数组 $extension = end($temp); // 获取文件后缀名 if ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;))//判断文件类型 &amp;&amp;($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 204800) // 判断文件大小 &amp;&amp; in_array($extension, $allowedExts)) //判断拆分的字符串能不能在允许的字符串中找到 { /*上传代码*/ } else { echo &quot;非法的文件格式&quot;; } 3.保存上传文件服务器的 PHP 临时文件夹中创建了一个被上传文件的临时副本，这个临时的副本文件会在脚本结束时消失。要保存被上传的文件，我们需要把它拷贝到另外的位置 if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))//检查文件是否存在 { echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在。 &quot;; } else { // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;文件存储在: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; } 完整代码 &lt;?php // 允许上传的图片后缀 $allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;); $temp = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); // 获取文件后缀名 if ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) ||($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) ||($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpg&quot;) ||($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;) ||($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;) ||($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;)) &amp;&amp;($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 204800) // 小于 200 kb &amp;&amp;in_array($extension, $allowedExts)){ if($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){ echo &quot;错误：: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;; } else{ echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br&gt;&quot;; // 判断当期目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])){ echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在。 &quot;; } else{ // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;文件存储在: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; } } } else{ echo &quot;非法的文件格式&quot;; } ?&gt; 文件上传错误码 值 错误 错误原因 0 UPLOAD_ERR_OK 没有错误发生，文件上传成功 1 UPLOAD_ERR_INI_SIZE 上传的文件超过了 php.ini 中 upload_max_filesize选项限制的值 2 UPLOAD_ERR_FORM_SIZE 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值 3 UPLOAD_ERR_PARTIAL 文件只有部分被上传 4 UPLOAD_ERR_NO_FILE 没有文件被上传 6 UPLOAD_ERR_NO_TMP_DIR 找不到临时文件夹 7 UPLOAD_ERR_CANT_WRITE 文件写入失败 文件上传中type值大全 Cookie创建Cookie setcookie(name, value, expire, path, domain); setcookie() 函数必须位于 标签之前 &lt;?php $expire=time()+60*60*24;//设置过期时间1天 setcookie(&quot;name&quot;, &quot;bob&quot;, $expire); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php if(isset($_COOKIE[&quot;name&quot;])){ echo &quot;欢迎 &quot; . $_COOKIE[&quot;name&quot;] . &quot;!&lt;br&gt;&quot;; // 查看所有 cookie print_r($_COOKIE); } else echo &quot;普通访客!&lt;br&gt;&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt; 输出结果 欢迎 bob! Array ([name] =&gt; bob ) 删除Cookie将时间设置过期 &lt;?php setcookie(&quot;name&quot;, &quot;&quot;, time()-60); ?&gt; Session1.工作机制：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导2.会话信息是临时的，在用户离开网站后将被删除 创建 Session session_start() session_start() 函数必须位于 标签之前 储存 Session键值对形式存储 $_SESSION[‘key’]=value 销毁 Session销毁指定键 unset() 销毁所有Session session_destroy() 电子邮件需要一个已安装且正在运行的邮件系统(如：sendmail、postfix、qmail等)。所用的程序通过在 php.ini 文件中的配置设置进行定义 参考 mail(to,subject,message,headers,parameters) 参数 描述 to 必需。规定 email 接收者 subject 必需。规定 email 的主题 message 必需。定义要发送的消息 headers 可选。规定附加的标题 parameters 可选。对邮件发送程序规定额外的参数 JSONjson_encodejson_encode() 用于对变量进行 JSON 编码，该函数如果执行成功返回 JSON 数据，否则返回 FALSE string json_encode ( \\$value [, \\$options = 0 ] ) 参数 含义 value 要编码的值。该函数只对 UTF-8 编码的数据有效 options 由以下常量组成的二进制掩码：JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK,JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT &lt;?php $arr = array(&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3); echo json_encode($arr).&quot;&lt;br /&gt;&quot;; class person{ public $name; public $age; public $sex; public function __construct($name,$age,$sex){ $this-&gt;name=$name; $this-&gt;age=$age; $this-&gt;sex=$sex; } } $p=new person(&quot;bob&quot;,18,&quot;man&quot;); echo json_encode($p); ?&gt; 输出结果 {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3} {&quot;name&quot;:&quot;bob&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;man&quot;} json_decodejson_decode() 函数用于对 JSON 格式的字符串进行解码，并转换为 PHP 变量 json_decode ( \\$ json_string [,\\$assoc = false [, \\$depth = 512 [, \\$options = 0 ]]]) 参数 含义 json_string 待解码的 JSON 字符串，必须是 UTF-8 编码数 assoc 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象 depth 整数类型的参数，它指定递归深 options 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING &lt;?php $json = &#39;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}&#39;; var_dump(json_decode($json)); var_dump(json_decode($json, true)); ?&gt; 输出结果 object(stdClass)[1] public &#39;a&#39; =&gt; int 1 public &#39;b&#39; =&gt; int 2 public &#39;c&#39; =&gt; int 3 array (size=3) &#39;a&#39; =&gt; int 1 &#39;b&#39; =&gt; int 2 &#39;c&#39; =&gt; int 3","categories":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}],"tags":[],"keywords":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}]},{"title":"PHP表单处理——PHP学习笔记（二）","slug":"ht/1559448766","date":"2019-06-02T04:12:46.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/06/02/ht/1559448766/","link":"","permalink":"/2019/06/02/ht/1559448766/","excerpt":"","text":"表单的处理输入框前端代码：前端代码包括一个HTML表单，action为提交的php文件，方法为post/get（见后文），表单中包含一个输入框以及提交按钮（属性为submit）。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; 姓名: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html 后端代码后端用超级全局变量$_POST接受前端的post方法传过来的值，post的键对应前端输入框的name属性 &lt;?php echo &quot;欢迎&quot;.$_POST[&quot;fname&quot;] ?&gt; 下拉菜单前端代码前端代码表达包含一个下拉选择框 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;test.php&quot; method=&quot;get&quot;&gt; &lt;select name=&quot;q&quot;&gt; &lt;option value=&quot;&quot;&gt;选择等级:&lt;/option&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html 后端代码后端用超级全局变量$_GET接受前端的get方法传过来的值，post的键对应前端输入框的name属性，值为下拉框中的value的值 &lt;?php $q=$_GET[&#39;q&#39;]; if($q==&#39;A&#39;){ echo &quot;你的成绩在80-100&quot;; }elseif($q==&#39;B&#39;){ echo &quot;你的成绩在60-80&quot;; }else{ echo &quot;你的成绩在60以下&quot;; } ?&gt; 下拉多选菜单 前端代码下拉菜单是多选的（ multiple=”multiple”），通过将设置 select name=”q[]” 以数组的方式获取 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;q[]&quot;&gt; &lt;option value=&quot;&quot;&gt;选择食物:&lt;/option&gt; &lt;option value=&quot;cake&quot;&gt;Cake&lt;/option&gt; &lt;option value=&quot;Chocolate&quot;&gt;Chocolate&lt;/option&gt; &lt;option value=&quot;Biscuits&quot;&gt;Biscuits&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 后端代码后端接收为一个数组 &lt;?php $q=$_POST[&#39;q&#39;]; echo &quot;你选择了&lt;br /&gt;&quot;; foreach($q as $val){ echo $val.&quot;&lt;br /&gt;&quot;; } ?&gt; 单选按钮前端代码单选框设置相同的name属性 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;cake&quot; /&gt;cake &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;Chocolate&quot; /&gt;Chocolate &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;Biscuits&quot; /&gt;Biscuits &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 后端代码 &lt;?php $q=$_POST[&#39;q&#39;]; echo &quot;你选择了&quot;.$q; ?&gt; 复选框 前端代码name属性设置为数组 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;cake&quot; /&gt;cake &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;Chocolate&quot; /&gt;Chocolate &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;Biscuits&quot; /&gt;Biscuits &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html 后端代码 &lt;?php $q=$_POST[&#39;q&#39;]; echo &quot;你选择了&lt;br /&gt;&quot;; foreach($q as $val){ echo $val.&quot;&lt;br /&gt;&quot;; } ?&gt; 表单的变量$_GET 1.$_GET 变量用于收集来自 method=”get” 的表单中的值 2.带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），在发送密码或其他敏感信息时，不使用 3.不能超过 2000 个字符，不适合大型变量 $_POST 1.$_POST 变量用于收集来自 method=”post” 的表单中的值 2.有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏）,无法加入书签 3.对发送信息的量也没有限制 $_REQUES $_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据","categories":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}],"tags":[],"keywords":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}]},{"title":"PHP基础知识——PHP学习笔记（一）","slug":"ht/1559020580","date":"2019-05-28T05:16:20.000Z","updated":"2020-06-11T02:57:18.397Z","comments":true,"path":"2019/05/28/ht/1559020580/","link":"","permalink":"/2019/05/28/ht/1559020580/","excerpt":"","text":"PHP规范 PHP代码写在&lt;?php?&gt; &lt;?php // 这里是PHP代码 ?&gt; php注释 //单行注释 /*多行注释*/ pho输出echo可以输出一个或多个字符串，无返回值 print只允许输出一个字符串，返回值总为 1 PHP变量命名规范1.变量名以 $ 符号开始，后面跟着变量的名称2.变量名必须以字母或者下划线字符开3.变量名只能包含字母数字字符以及下划线4.变量不能有空格，变量区分大小写 创建php变量名php不用申明变量，在第一次赋值的时候自动创建 局部作用域和全局作用域在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字在函数中调用全局变量 &lt;?php $x=1; // 全局变量 function test() { $y=2; // 局部变量 echo &quot;函数中调用x的值为:$x&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;函数中调用y的值为:$y&quot;; echo &quot;&lt;br&gt;&quot;; } test(); echo &quot;外部调用x的值为:$x&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;外部调用x的值为:$y&quot;; echo &quot;&lt;br&gt;&quot;; ?&gt; 输出结果为：函数中调用x的值为:函数中调用y的值为:2外部调用x的值为:1外部调用y的值为: &lt;?php $x=1; // 全局变量 function test() { global $x; // 局部变量 echo &quot;函数中调用x的值为:$x&quot;; echo &quot;&lt;br&gt;&quot;; $x=2; } test(); echo &quot;外部调用x的值为:$x&quot;; ?&gt; 输出结果为：函数中调用x的值为:1外部调用x的值为：2 PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。 Static 作用域当一个函数被完成时，局部变量会被删除，可使用Static关键字来保留局部变量 &lt;?php function test() { static $x=0; echo $x; $x++; echo &quot;&lt;br&gt;&quot;; // 换行符 } echo &quot;第1次使用函数x为:&quot;; test(); echo &quot;第2次使用函数x为:&quot;; test(); echo &quot;第3次使用函数x为:&quot;; test(); ?&gt; 输出结果 第1次使用函数x为:0 第2次使用函数x为:1 第3次使用函数x为:2 超级全局变量 变量名 描述 $GLOBALS $GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键 $_SERVER $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目$_SERVER中的元素 $_POST $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post” $_GET $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get” PHP常量常量值被定义后，在脚本的其他任何地方都不能被改变一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。常量是全局的 设置常量 bool define ( string $name , mixed $value [, bool $case_insensitive = false ] ) 参数 描述 name 必选参数，常量名称，即标志符 value 必选参数，常量的值 case_insensitive 可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感 &lt;?php define(&quot;TEST&quot;, &quot;不区分大小写&quot;,true); echo TEST; echo &#39;&lt;br&gt;&#39;; echo test; ?&gt; 输出结果 不区分大小写 不区分大小写 魔术常量 常量名 注释 __ LINE__ 文件中的当前行号 __ FILE__ 文件的完整路径和文件名 __ DIR__ 文件所在的目录 __ FUNCTION__ 函数名称 __ CLASS__ 类的名称 __ METHOD__ 类的方法名 __ NAMESPACE__ 当前命名空间的名称（区分大小写） 数据类型 函数返回变量的数据类型和值 var_dump() 类型 中文 注解 String 字符串 可放单引号和双引号中 Integer 整型 十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0） Float 浮点型 带小数部分的数字，或是指数形式 Boolean 布尔型 TRUE 或 FALSE Array 数组 一个变量中存储多个值 Object 对象 在 PHP 中，对象必须声明 NULL 空值 NULL 值表示变量没有值 &lt;?php $x = &quot;hello&quot;; //字符串 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 10;//整形 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 1.1;//浮点型 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = true; //布尔型 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = array(1,2,3); //数组 var_dump($x); echo &quot;&lt;br&gt;&quot;; $y; //空值 var_dump($y); ?&gt; 输出结果： E:\\WebProject\\phptest\\test.php:3:string &#39;hello&#39; (length=5 E:\\WebProject\\phptest\\test.php:6:int 1 E:\\WebProject\\phptest\\test.php:9:float 1. E:\\WebProject\\phptest\\test.php:12:boolean tru E:\\WebProject\\phptest\\test.php:15: array (size=3) 0 =&gt; int 1 1 =&gt; int 2 2 =&gt; int 3 E:\\WebProject\\phptest\\test.php:18:null 字符串1.字符串用 . 连接2.strlen() 函数返回字符串的长度（字符数）3.strpos(“”,””) 函数用于在字符串内查找一个字符或一段指定的文本，如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE &lt;?php echo strpos(&quot;Hello world!&quot;,&quot;world&quot;); ?&gt; 输出6 数组创建数组1.自动分配 ID 键 $变量名=array(“”,””,””) 2.人工分配 ID 键 \\$变量名[0]=””\\$变量名[1]=””\\$变量名[2]=”” 3.获取数组的长度count() 函数用于返回数组的长度4.关联数组 $变量名=array(“key”=&gt;”value”,”key”=&gt;”value”,”key”=&gt;”value”);or$变量名[key]=”value”$变量名[key]=”value”$变量名[key]=”value” 5.遍历关联数组 foreach($数组变量名 as $x=&gt;$x_value){} &lt;?php $score=array(&quot;NO.1&quot;=&gt;&quot;100&quot;,&quot;NO.2&quot;=&gt;&quot;90&quot;,&quot;NO.3&quot;=&gt;&quot;80&quot;); foreach($score as $x=&gt;$x_value) { echo $x . &quot;的成绩是&quot; . $x_value; echo &quot;&lt;br&gt;&quot;; } ?&gt; 输出结果 NO.1的成绩是100 NO.2的成绩是90 NO.3的成绩是80 6.数组排序 函数 注解 sort() 对数组进行升序排列 rsort() 对数组进行降序排列 asort() 根据关联数组的值，对数组进行升序排列 ksort() 根据关联数组的键，对数组进行升序排列 arsort() 根据关联数组的值，对数组进行降序排列 krsort() 根据关联数组的键，对数组进行降序排列 类型比较1.松散比较： == ，只比较值，不比较类型。2.严格比较：=== ，除了比较值，也比较类型3.比较运算符中&gt;=正确表达，返回布尔值4.优先级： &amp;&amp; &gt; = &gt; and5.优先级： || &gt; = &gt; or 命名空间引入的多个文件中可能存在同名的类、函数、常量，就会报错 定义命名空间命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间 &lt;?php namespace MyProject; const CONNECT_OK = 1;//常量 class Connection { /* ... */ }//类 function connect() { /* ... */}//函数 ?&gt; 空间成员1.空间只影响类、函数、常量(const)2.其他代码不受影响 子空间以及访问方式子空间命名 &lt;?php namespace MyProject\\Sub\\Level; //声明分层次的单个命名空间 const CONNECT_OK = 1; class Connection { /* ... */ } function Connect() { /* ... */ ?&gt; 访问方式 非限定访问:访问当前空间的成员 限定访问:只能访问当前空间的子空间的成员 子文件夹\\元素名 完全限定:可以访问其他空间的所有成员 \\空间名\\元素名 use 空间名\\空间名 【as 别名】：将指定空间引入到当前空间。同可以使用as关键字为被引入的空间起个别名 面向对象类的定义以及实例化1.类使用 class 关键字后加上类名定义2.类名后的一对大括号({})内可以定义变量和方法3.类的变量使用 var 来声明, 变量也可以初始化值。4.函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问5.变量 \\$this 代表自身的对象。-&gt;指向成员变量名称6.调用成员函数用-&gt; &lt;?php class Car{ /* 成员变量 */ var $cloor; /* 成员函数 */ function setCloor($col){ $this-&gt;cloor = $col; } function showCloor(){ echo $this-&gt;cloor; } } $Volvo=new Car; $Volvo-&gt;setCloor(&quot;red&quot;); $Volvo-&gt;showCloor(); ?&gt; php构造函数要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用 void __construct ([ mixed $args [, $… ]] ) &lt;?php class Car{ /* 成员变量 */ var $cloor; /* 成员函数 */ function __construct($col){ $this-&gt;cloor = $col; } function showCloor(){ echo $this-&gt;cloor; } } $Volvo=new Car(&quot;red&quot;); $Volvo-&gt;showCloor(); ?&gt; 析构函数当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函 void __destruct ( void ) 类的继承访问控制 public（公有）：公有的类成员可以在任何地方被访问。 protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。 private（私有）：私有的类成员则只能被其定义所在的类访问。 继承PHP 不支持多继承 &lt;?php class Car{ public $cloor; function __construct($col){ $this-&gt;cloor = $col; } function showCloor(){ echo $this-&gt;cloor; } } class Scar extends Car{ public $speed; function __construct($col,$spd){ $this-&gt;cloor = $col; $this-&gt;speed = $spd; } function showSpeed(){ echo &quot;&lt;br /&gt;&quot;.$this-&gt;speed; } } $Volvo=new SCar(&quot;red&quot;,55); $Volvo-&gt;showCloor(); $Volvo-&gt;showSpeed(); ?&gt; 接口1.使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容2.接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的3.接口中定义的所有方法都必须是公有，这是接口的特性4.要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 &lt;?php //定义接口 interface interface_1 { public function dosomething(); } // 实现接口 class interface_2 implements interface_1 { public function dosomething() { /**/ } } ?&gt; Static 关键字1.声明类属性或方法为 static(静态)，就可以不实例化类而直接访问,类名: :方法名2.静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）3.由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用4.静态属性不可以由对象通过 -&gt; 操作符来访问。 &lt;?php class test{ public static $my_static = &#39;test&#39;; public function showValue() { return self::$my_static; } } echo test::$my_static . &quot;&lt;br /&gt;&quot;; $test = new test(); echo $test-&gt;showValue(); ?&gt; Final 关键字如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。 调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() &lt;?php class parentclass{ function __construct(){ echo &quot;这是父类的构造方法&lt;br /&gt;&quot;; } } class childclass extends parentclass{ function __construct(){ parent::__construct(); echo &quot;这是子类的构造方法&quot;; } } $obj=new childclass; ?&gt; 输出结果 这是父类的构造方法 这是子类的构造方法","categories":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}],"tags":[],"keywords":[{"name":"ht","slug":"ht","permalink":"/categories/ht/"}]}]}